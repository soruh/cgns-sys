/* automatically generated by rust-bindgen */

pub const CGNS_VERSION: u32 = 4100;
pub const CGNS_DOTVERS: f64 = 4.1;
pub const CGNS_COMPATVERSION: u32 = 2540;
pub const CGNS_COMPATDOTVERS: f64 = 2.54;
pub const CG_BUILD_LEGACY: u32 = 1;
pub const CG_BUILD_64BIT: u32 = 0;
pub const CG_BUILD_SCOPE: u32 = 0;
pub const CG_BUILD_BASESCOPE: u32 = 0;
pub const CG_MAX_INT32: u32 = 2147483647;
pub const CG_HAVE_STAT64_STRUCT: u32 = 0;
pub const CG_SIZEOF_SIZE: u32 = 32;
pub const CG_SIZE_DATATYPE: &'static [u8; 3usize] = b"I4\0";
pub const FORTRAN_DEFAULT_INTEGER_C_INT64_T: u32 = 0;
pub const CG_MODE_READ: u32 = 0;
pub const CG_MODE_WRITE: u32 = 1;
pub const CG_MODE_MODIFY: u32 = 2;
pub const CG_MODE_CLOSED: u32 = 3;
pub const CG_FILE_NONE: u32 = 0;
pub const CG_FILE_ADF: u32 = 1;
pub const CG_FILE_HDF5: u32 = 2;
pub const CG_FILE_ADF2: u32 = 3;
pub const CG_OK: u32 = 0;
pub const CG_ERROR: u32 = 1;
pub const CG_NODE_NOT_FOUND: u32 = 2;
pub const CG_INCORRECT_PATH: u32 = 3;
pub const CG_NO_INDEX_DIM: u32 = 4;
pub const CG_Null: u32 = 0;
pub const CG_UserDefined: u32 = 1;
pub const CG_MAX_GOTO_DEPTH: u32 = 20;
pub const CG_CONFIG_ERROR: u32 = 1;
pub const CG_CONFIG_COMPRESS: u32 = 2;
pub const CG_CONFIG_SET_PATH: u32 = 3;
pub const CG_CONFIG_ADD_PATH: u32 = 4;
pub const CG_CONFIG_FILE_TYPE: u32 = 5;
pub const CG_CONFIG_RIND_INDEX: u32 = 6;
pub const CG_CONFIG_HDF5_COMPRESS: u32 = 201;
pub const CG_CONFIG_HDF5_MPI_COMM: u32 = 202;
pub const CG_CONTIGUOUS: u32 = 0;
pub const CG_COMPACT: u32 = 1;
pub const CG_CHUNKED: u32 = 2;
pub const NofValidMassUnits: u32 = 6;
pub const NofValidLengthUnits: u32 = 7;
pub const NofValidTimeUnits: u32 = 3;
pub const NofValidTemperatureUnits: u32 = 6;
pub const NofValidAngleUnits: u32 = 4;
pub const NofValidElectricCurrentUnits: u32 = 7;
pub const NofValidSubstanceAmountUnits: u32 = 6;
pub const NofValidLuminousIntensityUnits: u32 = 7;
pub const NofValidDataClass: u32 = 7;
pub const NofValidGridLocation: u32 = 9;
pub const NofValidBCDataTypes: u32 = 4;
pub const NofValidGridConnectivityTypes: u32 = 5;
pub const NofValidPointSetTypes: u32 = 9;
pub const NofValidGoverningEquationsTypes: u32 = 8;
pub const NofValidModelTypes: u32 = 36;
pub const NofValidBCTypes: u32 = 26;
pub const NofValidDataTypes: u32 = 7;
pub const NofValidElementTypes: u32 = 57;
pub const NPE_NODE: u32 = 1;
pub const NPE_BAR_2: u32 = 2;
pub const NPE_BAR_3: u32 = 3;
pub const NPE_TRI_3: u32 = 3;
pub const NPE_TRI_6: u32 = 6;
pub const NPE_QUAD_4: u32 = 4;
pub const NPE_QUAD_8: u32 = 8;
pub const NPE_QUAD_9: u32 = 9;
pub const NPE_TETRA_4: u32 = 4;
pub const NPE_TETRA_10: u32 = 10;
pub const NPE_PYRA_5: u32 = 5;
pub const NPE_PYRA_13: u32 = 13;
pub const NPE_PYRA_14: u32 = 14;
pub const NPE_PENTA_6: u32 = 6;
pub const NPE_PENTA_15: u32 = 15;
pub const NPE_PENTA_18: u32 = 18;
pub const NPE_HEXA_8: u32 = 8;
pub const NPE_HEXA_20: u32 = 20;
pub const NPE_HEXA_27: u32 = 27;
pub const NPE_MIXED: u32 = 0;
pub const NPE_NGON_n: u32 = 0;
pub const NPE_NFACE_n: u32 = 0;
pub const NPE_BAR_4: u32 = 4;
pub const NPE_TRI_9: u32 = 9;
pub const NPE_TRI_10: u32 = 10;
pub const NPE_QUAD_12: u32 = 12;
pub const NPE_QUAD_16: u32 = 16;
pub const NPE_TETRA_16: u32 = 16;
pub const NPE_TETRA_20: u32 = 20;
pub const NPE_PYRA_21: u32 = 21;
pub const NPE_PYRA_29: u32 = 29;
pub const NPE_PYRA_30: u32 = 30;
pub const NPE_PENTA_24: u32 = 24;
pub const NPE_PENTA_38: u32 = 38;
pub const NPE_PENTA_40: u32 = 40;
pub const NPE_HEXA_32: u32 = 32;
pub const NPE_HEXA_56: u32 = 56;
pub const NPE_HEXA_64: u32 = 64;
pub const NPE_BAR_5: u32 = 5;
pub const NPE_TRI_12: u32 = 12;
pub const NPE_TRI_15: u32 = 15;
pub const NPE_QUAD_P4_16: u32 = 16;
pub const NPE_QUAD_25: u32 = 25;
pub const NPE_TETRA_22: u32 = 22;
pub const NPE_TETRA_34: u32 = 34;
pub const NPE_TETRA_35: u32 = 35;
pub const NPE_PYRA_P4_29: u32 = 29;
pub const NPE_PYRA_50: u32 = 50;
pub const NPE_PYRA_55: u32 = 55;
pub const NPE_PENTA_33: u32 = 33;
pub const NPE_PENTA_66: u32 = 66;
pub const NPE_PENTA_75: u32 = 75;
pub const NPE_HEXA_44: u32 = 44;
pub const NPE_HEXA_98: u32 = 98;
pub const NPE_HEXA_125: u32 = 125;
pub const NofValidZoneTypes: u32 = 4;
pub const NofValidRigidGridMotionTypes: u32 = 4;
pub const NofValidArbitraryGridMotionTypes: u32 = 4;
pub const NofValidSimulationTypes: u32 = 4;
pub const NofValidWallFunctionTypes: u32 = 3;
pub const NofValidAreaTypes: u32 = 4;
pub const NofValidAverageInterfaceTypes: u32 = 8;
pub type cgint_f = ::std::os::raw::c_int;
pub type cglong_t = ::std::os::raw::c_long;
pub type cgulong_t = ::std::os::raw::c_ulong;
pub const MassUnits_t_MassUnitsNull: MassUnits_t = 0;
pub const MassUnits_t_MassUnitsUserDefined: MassUnits_t = 1;
pub const MassUnits_t_Kilogram: MassUnits_t = 2;
pub const MassUnits_t_Gram: MassUnits_t = 3;
pub const MassUnits_t_Slug: MassUnits_t = 4;
pub const MassUnits_t_PoundMass: MassUnits_t = 5;
pub type MassUnits_t = u32;
pub const LengthUnits_t_LengthUnitsNull: LengthUnits_t = 0;
pub const LengthUnits_t_LengthUnitsUserDefined: LengthUnits_t = 1;
pub const LengthUnits_t_Meter: LengthUnits_t = 2;
pub const LengthUnits_t_Centimeter: LengthUnits_t = 3;
pub const LengthUnits_t_Millimeter: LengthUnits_t = 4;
pub const LengthUnits_t_Foot: LengthUnits_t = 5;
pub const LengthUnits_t_Inch: LengthUnits_t = 6;
pub type LengthUnits_t = u32;
pub const TimeUnits_t_TimeUnitsNull: TimeUnits_t = 0;
pub const TimeUnits_t_TimeUnitsUserDefined: TimeUnits_t = 1;
pub const TimeUnits_t_Second: TimeUnits_t = 2;
pub type TimeUnits_t = u32;
pub const TemperatureUnits_t_TemperatureUnitsNull: TemperatureUnits_t = 0;
pub const TemperatureUnits_t_TemperatureUnitsUserDefined: TemperatureUnits_t = 1;
pub const TemperatureUnits_t_Kelvin: TemperatureUnits_t = 2;
pub const TemperatureUnits_t_Celsius: TemperatureUnits_t = 3;
pub const TemperatureUnits_t_Rankine: TemperatureUnits_t = 4;
pub const TemperatureUnits_t_Fahrenheit: TemperatureUnits_t = 5;
pub type TemperatureUnits_t = u32;
pub const AngleUnits_t_AngleUnitsNull: AngleUnits_t = 0;
pub const AngleUnits_t_AngleUnitsUserDefined: AngleUnits_t = 1;
pub const AngleUnits_t_Degree: AngleUnits_t = 2;
pub const AngleUnits_t_Radian: AngleUnits_t = 3;
pub type AngleUnits_t = u32;
pub const ElectricCurrentUnits_t_ElectricCurrentUnitsNull: ElectricCurrentUnits_t = 0;
pub const ElectricCurrentUnits_t_ElectricCurrentUnitsUserDefined: ElectricCurrentUnits_t = 1;
pub const ElectricCurrentUnits_t_Ampere: ElectricCurrentUnits_t = 2;
pub const ElectricCurrentUnits_t_Abampere: ElectricCurrentUnits_t = 3;
pub const ElectricCurrentUnits_t_Statampere: ElectricCurrentUnits_t = 4;
pub const ElectricCurrentUnits_t_Edison: ElectricCurrentUnits_t = 5;
pub const ElectricCurrentUnits_t_auCurrent: ElectricCurrentUnits_t = 6;
pub type ElectricCurrentUnits_t = u32;
pub const SubstanceAmountUnits_t_SubstanceAmountUnitsNull: SubstanceAmountUnits_t = 0;
pub const SubstanceAmountUnits_t_SubstanceAmountUnitsUserDefined: SubstanceAmountUnits_t = 1;
pub const SubstanceAmountUnits_t_Mole: SubstanceAmountUnits_t = 2;
pub const SubstanceAmountUnits_t_Entities: SubstanceAmountUnits_t = 3;
pub const SubstanceAmountUnits_t_StandardCubicFoot: SubstanceAmountUnits_t = 4;
pub const SubstanceAmountUnits_t_StandardCubicMeter: SubstanceAmountUnits_t = 5;
pub type SubstanceAmountUnits_t = u32;
pub const LuminousIntensityUnits_t_LuminousIntensityUnitsNull: LuminousIntensityUnits_t = 0;
pub const LuminousIntensityUnits_t_LuminousIntensityUnitsUserDefined: LuminousIntensityUnits_t = 1;
pub const LuminousIntensityUnits_t_Candela: LuminousIntensityUnits_t = 2;
pub const LuminousIntensityUnits_t_Candle: LuminousIntensityUnits_t = 3;
pub const LuminousIntensityUnits_t_Carcel: LuminousIntensityUnits_t = 4;
pub const LuminousIntensityUnits_t_Hefner: LuminousIntensityUnits_t = 5;
pub const LuminousIntensityUnits_t_Violle: LuminousIntensityUnits_t = 6;
pub type LuminousIntensityUnits_t = u32;
extern "C" {
    pub static mut MassUnitsName: [*const ::std::os::raw::c_char; 6usize];
}
extern "C" {
    pub static mut LengthUnitsName: [*const ::std::os::raw::c_char; 7usize];
}
extern "C" {
    pub static mut TimeUnitsName: [*const ::std::os::raw::c_char; 3usize];
}
extern "C" {
    pub static mut TemperatureUnitsName: [*const ::std::os::raw::c_char; 6usize];
}
extern "C" {
    pub static mut AngleUnitsName: [*const ::std::os::raw::c_char; 4usize];
}
extern "C" {
    pub static mut ElectricCurrentUnitsName: [*const ::std::os::raw::c_char; 7usize];
}
extern "C" {
    pub static mut SubstanceAmountUnitsName: [*const ::std::os::raw::c_char; 6usize];
}
extern "C" {
    pub static mut LuminousIntensityUnitsName: [*const ::std::os::raw::c_char; 7usize];
}
pub const DataClass_t_DataClassNull: DataClass_t = 0;
pub const DataClass_t_DataClassUserDefined: DataClass_t = 1;
pub const DataClass_t_Dimensional: DataClass_t = 2;
pub const DataClass_t_NormalizedByDimensional: DataClass_t = 3;
pub const DataClass_t_NormalizedByUnknownDimensional: DataClass_t = 4;
pub const DataClass_t_NondimensionalParameter: DataClass_t = 5;
pub const DataClass_t_DimensionlessConstant: DataClass_t = 6;
pub type DataClass_t = u32;
extern "C" {
    pub static mut DataClassName: [*const ::std::os::raw::c_char; 7usize];
}
pub const GridLocation_t_GridLocationNull: GridLocation_t = 0;
pub const GridLocation_t_GridLocationUserDefined: GridLocation_t = 1;
pub const GridLocation_t_Vertex: GridLocation_t = 2;
pub const GridLocation_t_CellCenter: GridLocation_t = 3;
pub const GridLocation_t_FaceCenter: GridLocation_t = 4;
pub const GridLocation_t_IFaceCenter: GridLocation_t = 5;
pub const GridLocation_t_JFaceCenter: GridLocation_t = 6;
pub const GridLocation_t_KFaceCenter: GridLocation_t = 7;
pub const GridLocation_t_EdgeCenter: GridLocation_t = 8;
pub type GridLocation_t = u32;
extern "C" {
    pub static mut GridLocationName: [*const ::std::os::raw::c_char; 9usize];
}
pub const BCDataType_t_BCDataTypeNull: BCDataType_t = 0;
pub const BCDataType_t_BCDataTypeUserDefined: BCDataType_t = 1;
pub const BCDataType_t_Dirichlet: BCDataType_t = 2;
pub const BCDataType_t_Neumann: BCDataType_t = 3;
pub type BCDataType_t = u32;
extern "C" {
    pub static mut BCDataTypeName: [*const ::std::os::raw::c_char; 4usize];
}
pub const GridConnectivityType_t_GridConnectivityTypeNull: GridConnectivityType_t = 0;
pub const GridConnectivityType_t_GridConnectivityTypeUserDefined: GridConnectivityType_t = 1;
pub const GridConnectivityType_t_Overset: GridConnectivityType_t = 2;
pub const GridConnectivityType_t_Abutting: GridConnectivityType_t = 3;
pub const GridConnectivityType_t_Abutting1to1: GridConnectivityType_t = 4;
pub type GridConnectivityType_t = u32;
extern "C" {
    pub static mut GridConnectivityTypeName: [*const ::std::os::raw::c_char; 5usize];
}
pub const PointSetType_t_PointSetTypeNull: PointSetType_t = 0;
pub const PointSetType_t_PointSetTypeUserDefined: PointSetType_t = 1;
pub const PointSetType_t_PointList: PointSetType_t = 2;
pub const PointSetType_t_PointListDonor: PointSetType_t = 3;
pub const PointSetType_t_PointRange: PointSetType_t = 4;
pub const PointSetType_t_PointRangeDonor: PointSetType_t = 5;
pub const PointSetType_t_ElementRange: PointSetType_t = 6;
pub const PointSetType_t_ElementList: PointSetType_t = 7;
pub const PointSetType_t_CellListDonor: PointSetType_t = 8;
pub type PointSetType_t = u32;
extern "C" {
    pub static mut PointSetTypeName: [*const ::std::os::raw::c_char; 9usize];
}
pub const GoverningEquationsType_t_GoverningEquationsNull: GoverningEquationsType_t = 0;
pub const GoverningEquationsType_t_GoverningEquationsUserDefined: GoverningEquationsType_t = 1;
pub const GoverningEquationsType_t_FullPotential: GoverningEquationsType_t = 2;
pub const GoverningEquationsType_t_Euler: GoverningEquationsType_t = 3;
pub const GoverningEquationsType_t_NSLaminar: GoverningEquationsType_t = 4;
pub const GoverningEquationsType_t_NSTurbulent: GoverningEquationsType_t = 5;
pub const GoverningEquationsType_t_NSLaminarIncompressible: GoverningEquationsType_t = 6;
pub const GoverningEquationsType_t_NSTurbulentIncompressible: GoverningEquationsType_t = 7;
pub type GoverningEquationsType_t = u32;
pub const ModelType_t_ModelTypeNull: ModelType_t = 0;
pub const ModelType_t_ModelTypeUserDefined: ModelType_t = 1;
pub const ModelType_t_Ideal: ModelType_t = 2;
pub const ModelType_t_VanderWaals: ModelType_t = 3;
pub const ModelType_t_Constant: ModelType_t = 4;
pub const ModelType_t_PowerLaw: ModelType_t = 5;
pub const ModelType_t_SutherlandLaw: ModelType_t = 6;
pub const ModelType_t_ConstantPrandtl: ModelType_t = 7;
pub const ModelType_t_EddyViscosity: ModelType_t = 8;
pub const ModelType_t_ReynoldsStress: ModelType_t = 9;
pub const ModelType_t_ReynoldsStressAlgebraic: ModelType_t = 10;
pub const ModelType_t_Algebraic_BaldwinLomax: ModelType_t = 11;
pub const ModelType_t_Algebraic_CebeciSmith: ModelType_t = 12;
pub const ModelType_t_HalfEquation_JohnsonKing: ModelType_t = 13;
pub const ModelType_t_OneEquation_BaldwinBarth: ModelType_t = 14;
pub const ModelType_t_OneEquation_SpalartAllmaras: ModelType_t = 15;
pub const ModelType_t_TwoEquation_JonesLaunder: ModelType_t = 16;
pub const ModelType_t_TwoEquation_MenterSST: ModelType_t = 17;
pub const ModelType_t_TwoEquation_Wilcox: ModelType_t = 18;
pub const ModelType_t_CaloricallyPerfect: ModelType_t = 19;
pub const ModelType_t_ThermallyPerfect: ModelType_t = 20;
pub const ModelType_t_ConstantDensity: ModelType_t = 21;
pub const ModelType_t_RedlichKwong: ModelType_t = 22;
pub const ModelType_t_Frozen: ModelType_t = 23;
pub const ModelType_t_ThermalEquilib: ModelType_t = 24;
pub const ModelType_t_ThermalNonequilib: ModelType_t = 25;
pub const ModelType_t_ChemicalEquilibCurveFit: ModelType_t = 26;
pub const ModelType_t_ChemicalEquilibMinimization: ModelType_t = 27;
pub const ModelType_t_ChemicalNonequilib: ModelType_t = 28;
pub const ModelType_t_EMElectricField: ModelType_t = 29;
pub const ModelType_t_EMMagneticField: ModelType_t = 30;
pub const ModelType_t_EMConductivity: ModelType_t = 31;
pub const ModelType_t_Voltage: ModelType_t = 32;
pub const ModelType_t_Interpolated: ModelType_t = 33;
pub const ModelType_t_Equilibrium_LinRessler: ModelType_t = 34;
pub const ModelType_t_Chemistry_LinRessler: ModelType_t = 35;
pub type ModelType_t = u32;
extern "C" {
    pub static mut GoverningEquationsTypeName: [*const ::std::os::raw::c_char; 8usize];
}
extern "C" {
    pub static mut ModelTypeName: [*const ::std::os::raw::c_char; 36usize];
}
pub const BCType_t_BCTypeNull: BCType_t = 0;
pub const BCType_t_BCTypeUserDefined: BCType_t = 1;
pub const BCType_t_BCAxisymmetricWedge: BCType_t = 2;
pub const BCType_t_BCDegenerateLine: BCType_t = 3;
pub const BCType_t_BCDegeneratePoint: BCType_t = 4;
pub const BCType_t_BCDirichlet: BCType_t = 5;
pub const BCType_t_BCExtrapolate: BCType_t = 6;
pub const BCType_t_BCFarfield: BCType_t = 7;
pub const BCType_t_BCGeneral: BCType_t = 8;
pub const BCType_t_BCInflow: BCType_t = 9;
pub const BCType_t_BCInflowSubsonic: BCType_t = 10;
pub const BCType_t_BCInflowSupersonic: BCType_t = 11;
pub const BCType_t_BCNeumann: BCType_t = 12;
pub const BCType_t_BCOutflow: BCType_t = 13;
pub const BCType_t_BCOutflowSubsonic: BCType_t = 14;
pub const BCType_t_BCOutflowSupersonic: BCType_t = 15;
pub const BCType_t_BCSymmetryPlane: BCType_t = 16;
pub const BCType_t_BCSymmetryPolar: BCType_t = 17;
pub const BCType_t_BCTunnelInflow: BCType_t = 18;
pub const BCType_t_BCTunnelOutflow: BCType_t = 19;
pub const BCType_t_BCWall: BCType_t = 20;
pub const BCType_t_BCWallInviscid: BCType_t = 21;
pub const BCType_t_BCWallViscous: BCType_t = 22;
pub const BCType_t_BCWallViscousHeatFlux: BCType_t = 23;
pub const BCType_t_BCWallViscousIsothermal: BCType_t = 24;
pub const BCType_t_FamilySpecified: BCType_t = 25;
pub type BCType_t = u32;
extern "C" {
    pub static mut BCTypeName: [*const ::std::os::raw::c_char; 26usize];
}
pub const DataType_t_DataTypeNull: DataType_t = 0;
pub const DataType_t_DataTypeUserDefined: DataType_t = 1;
pub const DataType_t_Integer: DataType_t = 2;
pub const DataType_t_RealSingle: DataType_t = 3;
pub const DataType_t_RealDouble: DataType_t = 4;
pub const DataType_t_Character: DataType_t = 5;
pub const DataType_t_LongInteger: DataType_t = 6;
pub type DataType_t = u32;
extern "C" {
    pub static mut DataTypeName: [*const ::std::os::raw::c_char; 7usize];
}
pub const ElementType_t_ElementTypeNull: ElementType_t = 0;
pub const ElementType_t_ElementTypeUserDefined: ElementType_t = 1;
pub const ElementType_t_NODE: ElementType_t = 2;
pub const ElementType_t_BAR_2: ElementType_t = 3;
pub const ElementType_t_BAR_3: ElementType_t = 4;
pub const ElementType_t_TRI_3: ElementType_t = 5;
pub const ElementType_t_TRI_6: ElementType_t = 6;
pub const ElementType_t_QUAD_4: ElementType_t = 7;
pub const ElementType_t_QUAD_8: ElementType_t = 8;
pub const ElementType_t_QUAD_9: ElementType_t = 9;
pub const ElementType_t_TETRA_4: ElementType_t = 10;
pub const ElementType_t_TETRA_10: ElementType_t = 11;
pub const ElementType_t_PYRA_5: ElementType_t = 12;
pub const ElementType_t_PYRA_14: ElementType_t = 13;
pub const ElementType_t_PENTA_6: ElementType_t = 14;
pub const ElementType_t_PENTA_15: ElementType_t = 15;
pub const ElementType_t_PENTA_18: ElementType_t = 16;
pub const ElementType_t_HEXA_8: ElementType_t = 17;
pub const ElementType_t_HEXA_20: ElementType_t = 18;
pub const ElementType_t_HEXA_27: ElementType_t = 19;
pub const ElementType_t_MIXED: ElementType_t = 20;
pub const ElementType_t_PYRA_13: ElementType_t = 21;
pub const ElementType_t_NGON_n: ElementType_t = 22;
pub const ElementType_t_NFACE_n: ElementType_t = 23;
pub const ElementType_t_BAR_4: ElementType_t = 24;
pub const ElementType_t_TRI_9: ElementType_t = 25;
pub const ElementType_t_TRI_10: ElementType_t = 26;
pub const ElementType_t_QUAD_12: ElementType_t = 27;
pub const ElementType_t_QUAD_16: ElementType_t = 28;
pub const ElementType_t_TETRA_16: ElementType_t = 29;
pub const ElementType_t_TETRA_20: ElementType_t = 30;
pub const ElementType_t_PYRA_21: ElementType_t = 31;
pub const ElementType_t_PYRA_29: ElementType_t = 32;
pub const ElementType_t_PYRA_30: ElementType_t = 33;
pub const ElementType_t_PENTA_24: ElementType_t = 34;
pub const ElementType_t_PENTA_38: ElementType_t = 35;
pub const ElementType_t_PENTA_40: ElementType_t = 36;
pub const ElementType_t_HEXA_32: ElementType_t = 37;
pub const ElementType_t_HEXA_56: ElementType_t = 38;
pub const ElementType_t_HEXA_64: ElementType_t = 39;
pub const ElementType_t_BAR_5: ElementType_t = 40;
pub const ElementType_t_TRI_12: ElementType_t = 41;
pub const ElementType_t_TRI_15: ElementType_t = 42;
pub const ElementType_t_QUAD_P4_16: ElementType_t = 43;
pub const ElementType_t_QUAD_25: ElementType_t = 44;
pub const ElementType_t_TETRA_22: ElementType_t = 45;
pub const ElementType_t_TETRA_34: ElementType_t = 46;
pub const ElementType_t_TETRA_35: ElementType_t = 47;
pub const ElementType_t_PYRA_P4_29: ElementType_t = 48;
pub const ElementType_t_PYRA_50: ElementType_t = 49;
pub const ElementType_t_PYRA_55: ElementType_t = 50;
pub const ElementType_t_PENTA_33: ElementType_t = 51;
pub const ElementType_t_PENTA_66: ElementType_t = 52;
pub const ElementType_t_PENTA_75: ElementType_t = 53;
pub const ElementType_t_HEXA_44: ElementType_t = 54;
pub const ElementType_t_HEXA_98: ElementType_t = 55;
pub const ElementType_t_HEXA_125: ElementType_t = 56;
pub type ElementType_t = u32;
extern "C" {
    pub static mut ElementTypeName: [*const ::std::os::raw::c_char; 57usize];
}
pub const ZoneType_t_ZoneTypeNull: ZoneType_t = 0;
pub const ZoneType_t_ZoneTypeUserDefined: ZoneType_t = 1;
pub const ZoneType_t_Structured: ZoneType_t = 2;
pub const ZoneType_t_Unstructured: ZoneType_t = 3;
pub type ZoneType_t = u32;
extern "C" {
    pub static mut ZoneTypeName: [*const ::std::os::raw::c_char; 4usize];
}
pub const RigidGridMotionType_t_RigidGridMotionTypeNull: RigidGridMotionType_t = 0;
pub const RigidGridMotionType_t_RigidGridMotionTypeUserDefined: RigidGridMotionType_t = 1;
pub const RigidGridMotionType_t_ConstantRate: RigidGridMotionType_t = 2;
pub const RigidGridMotionType_t_VariableRate: RigidGridMotionType_t = 3;
pub type RigidGridMotionType_t = u32;
extern "C" {
    pub static mut RigidGridMotionTypeName: [*const ::std::os::raw::c_char; 4usize];
}
pub const ArbitraryGridMotionType_t_ArbitraryGridMotionTypeNull: ArbitraryGridMotionType_t = 0;
pub const ArbitraryGridMotionType_t_ArbitraryGridMotionTypeUserDefined: ArbitraryGridMotionType_t =
    1;
pub const ArbitraryGridMotionType_t_NonDeformingGrid: ArbitraryGridMotionType_t = 2;
pub const ArbitraryGridMotionType_t_DeformingGrid: ArbitraryGridMotionType_t = 3;
pub type ArbitraryGridMotionType_t = u32;
extern "C" {
    pub static mut ArbitraryGridMotionTypeName: [*const ::std::os::raw::c_char; 4usize];
}
pub const SimulationType_t_SimulationTypeNull: SimulationType_t = 0;
pub const SimulationType_t_SimulationTypeUserDefined: SimulationType_t = 1;
pub const SimulationType_t_TimeAccurate: SimulationType_t = 2;
pub const SimulationType_t_NonTimeAccurate: SimulationType_t = 3;
pub type SimulationType_t = u32;
extern "C" {
    pub static mut SimulationTypeName: [*const ::std::os::raw::c_char; 4usize];
}
pub const WallFunctionType_t_WallFunctionTypeNull: WallFunctionType_t = 0;
pub const WallFunctionType_t_WallFunctionTypeUserDefined: WallFunctionType_t = 1;
pub const WallFunctionType_t_Generic: WallFunctionType_t = 2;
pub type WallFunctionType_t = u32;
pub const AreaType_t_AreaTypeNull: AreaType_t = 0;
pub const AreaType_t_AreaTypeUserDefined: AreaType_t = 1;
pub const AreaType_t_BleedArea: AreaType_t = 2;
pub const AreaType_t_CaptureArea: AreaType_t = 3;
pub type AreaType_t = u32;
extern "C" {
    pub static mut WallFunctionTypeName: [*const ::std::os::raw::c_char; 3usize];
}
extern "C" {
    pub static mut AreaTypeName: [*const ::std::os::raw::c_char; 4usize];
}
pub const AverageInterfaceType_t_AverageInterfaceTypeNull: AverageInterfaceType_t = 0;
pub const AverageInterfaceType_t_AverageInterfaceTypeUserDefined: AverageInterfaceType_t = 1;
pub const AverageInterfaceType_t_AverageAll: AverageInterfaceType_t = 2;
pub const AverageInterfaceType_t_AverageCircumferential: AverageInterfaceType_t = 3;
pub const AverageInterfaceType_t_AverageRadial: AverageInterfaceType_t = 4;
pub const AverageInterfaceType_t_AverageI: AverageInterfaceType_t = 5;
pub const AverageInterfaceType_t_AverageJ: AverageInterfaceType_t = 6;
pub const AverageInterfaceType_t_AverageK: AverageInterfaceType_t = 7;
pub type AverageInterfaceType_t = u32;
extern "C" {
    pub static mut AverageInterfaceTypeName: [*const ::std::os::raw::c_char; 8usize];
}
extern "C" {
    /// Check for a valid CGNS file
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &larr; `file_type`(`int*`): Type of CGNS file. This will typically be either `CG_FILE_ADF` or `CG_FILE_HDF5` depending on the underlying file format. However, note that when built in 32-bit, there is also an option to create a Version 2.5 CGNS file by setting the file type to `CG_FILE_ADF2`.
    pub fn cg_is_cgns(
        filename: *const ::std::os::raw::c_char,
        file_type: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Open a CGNS file
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `filename`(`char*`): Name of the CGNS file, including path name if necessary. There is no limit on the length of this character variable.
    /// 
    /// &rarr; `mode`(`int`): Mode used for opening the file. The modes currently supported are `CG_MODE_READ`, `CG_MODE_WRITE`, and `CG_MODE_MODIFY`.
    /// 
    /// &larr; `fn`(`int*`): CGNS file index number.
    pub fn cg_open(
        filename: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        fn_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get CGNS file version
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &larr; `version`(`float*`): CGNS version number.
    pub fn cg_version(fn_: ::std::os::raw::c_int, FileVersion: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get CGNS file precision
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &larr; `precision`(`int*`): Precision used to write the CGNS file. The return value will be one of 32 (32-bit), 64 (64-bit), or 0 if not known.
    pub fn cg_precision(
        fn_: ::std::os::raw::c_int,
        precision: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Close a CGNS file
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    pub fn cg_close(fn_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Save the open CGNS file
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &rarr; `file_type`(`int`): Type of CGNS file. This will typically be either `CG_FILE_ADF` or `CG_FILE_HDF5` depending on the underlying file format. However, note that when built in 32-bit, there is also an option to create a Version 2.5 CGNS file by setting the file type to `CG_FILE_ADF2`.
    /// 
    /// &rarr; `follow_links`(`int`): This flag determines whether links are left intact when saving a CGNS file. If non-zero, then the links will be removed and the data associated with the linked files copied to the new file.
    pub fn cg_save_as(
        fn_: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        file_type: ::std::os::raw::c_int,
        follow_links: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set default file type
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `file_type`(`int`): Type of CGNS file. This will typically be either `CG_FILE_ADF` or `CG_FILE_HDF5` depending on the underlying file format. However, note that when built in 32-bit, there is also an option to create a Version 2.5 CGNS file by setting the file type to `CG_FILE_ADF2`.
    pub fn cg_set_file_type(file_type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get file type for open CGNS file
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &larr; `file_type`(`int*`): Type of CGNS file. This will typically be either `CG_FILE_ADF` or `CG_FILE_HDF5` depending on the underlying file format. However, note that when built in 32-bit, there is also an option to create a Version 2.5 CGNS file by setting the file type to `CG_FILE_ADF2`.
    pub fn cg_get_file_type(
        fn_: ::std::os::raw::c_int,
        file_type: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get the root node ID
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &larr; `rootid`(`double*`): Root node identifier for the CGNS file.
    pub fn cg_root_id(fn_: ::std::os::raw::c_int, rootid: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &larr; `cgio_num`(`int*`): CGIO indentifier for the CGNS file.
    pub fn cg_get_cgio(
        fn_: ::std::os::raw::c_int,
        cgio_num: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `option`(`int`): The option to configure, currently one of `CG_CONFIG_ERROR`, `CG_CONFIG_COMPRESS`, `CG_CONFIG_SET_PATH`, `CG_CONFIG_ADD_PATH`, `CG_CONFIG_FILE_TYPE`, `CG_CONFIG_RIND_INDEX`, `CG_CONFIG_HDF5_COMPRESS`, or `CG_CONFIG_HDF5_MPI_COMM` as defined in <i>cgnslib.h</i>.
    /// 
    /// &rarr; `value`(`void*`): The value to set, type cast as `void *`.
    pub fn cg_configure(
        what: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `(`(`void`): undefined
    pub fn cg_error_handler(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_char),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `compress`(`int`): CGNS compress (rewrite) setting.
    pub fn cg_set_compress(compress: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `compress`(`int*`): CGNS compress (rewrite) setting.
    pub fn cg_get_compress(compress: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `char `(`const`): undefined
    pub fn cg_set_path(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add to the CGNS link search path
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `char `(`const`): undefined
    pub fn cg_add_path(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_get_name(
        nnames: ::std::os::raw::c_int,
        names: *mut *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_MassUnitsName(type_: MassUnits_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_LengthUnitsName(type_: LengthUnits_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_TimeUnitsName(type_: TimeUnits_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_TemperatureUnitsName(type_: TemperatureUnits_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_AngleUnitsName(type_: AngleUnits_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_ElectricCurrentUnitsName(
        type_: ElectricCurrentUnits_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_SubstanceAmountUnitsName(
        type_: SubstanceAmountUnits_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_LuminousIntensityUnitsName(
        type_: LuminousIntensityUnits_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_DataClassName(type_: DataClass_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_GridLocationName(type_: GridLocation_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_BCDataTypeName(type_: BCDataType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_GridConnectivityTypeName(
        type_: GridConnectivityType_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_PointSetTypeName(type_: PointSetType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_GoverningEquationsTypeName(
        type_: GoverningEquationsType_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_ModelTypeName(type_: ModelType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_BCTypeName(type_: BCType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_DataTypeName(type_: DataType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_ElementTypeName(type_: ElementType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_ZoneTypeName(type_: ZoneType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_RigidGridMotionTypeName(
        type_: RigidGridMotionType_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_ArbitraryGridMotionTypeName(
        type_: ArbitraryGridMotionType_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_SimulationTypeName(type_: SimulationType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_WallFunctionTypeName(type_: WallFunctionType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_AreaTypeName(type_: AreaType_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_AverageInterfaceTypeName(
        type_: AverageInterfaceType_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &larr; `nbases`(`int*`): Number of bases present in the CGNS file `fn`.
    pub fn cg_nbases(
        fn_: ::std::os::raw::c_int,
        nbases: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `basename`(`char*`): Name of the base.
    /// 
    /// &larr; `cell_dim`(`int*`): Dimension of the cells; 3 for volume cells, 2 for surface cells and 1 for line cells.
    /// 
    /// &larr; `phys_dim`(`int*`): Number of coordinates required to define a vector in the field.
    pub fn cg_base_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        basename: *mut ::std::os::raw::c_char,
        cell_dim: *mut ::std::os::raw::c_int,
        phys_dim: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_base_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        base_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `basename`(`char*`): Name of the base.
    /// 
    /// &rarr; `cell_dim`(`int`): Dimension of the cells; 3 for volume cells, 2 for surface cells and 1 for line cells.
    /// 
    /// &rarr; `phys_dim`(`int`): Number of coordinates required to define a vector in the field.
    /// 
    /// &larr; `B`(`int*`): Base index number, where 1 &le; `B` &le; `nbases`.
    pub fn cg_base_write(
        file_number: ::std::os::raw::c_int,
        basename: *const ::std::os::raw::c_char,
        cell_dim: ::std::os::raw::c_int,
        phys_dim: ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the cell dimension for the CGNS base
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `cell_dim`(`int*`): Dimension of the cells; 3 for volume cells, 2 for surface cells and 1 for line cells.
    pub fn cg_cell_dim(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        cell_dim: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `nzones`(`int*`): Number of zones present in base `B`.
    pub fn cg_nzones(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        nzones: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `zonename`(`char*`): Name of the zone.
    /// 
    /// &larr; `size`(`cgsize_t*`): Number of vertices, cells, and boundary vertices in each (<i>index</i>)-dimension.  For structured grids, the dimensions have unit stride in the array (e.g., `[NVertexI, NVertexJ, NVertexK, NCellI, NCellJ, NCellK, NBoundVertexI, NBoundVertexJ, NBoundVertexK]`). <p> Note that for unstructured grids, the number of cells is the number of highest order elements. Thus, in three dimensions it's the number of 3-D cells, and in two dimensions it's the number of 2-D cells. <p> Also for unstructured grids, if the nodes are sorted between internal nodes and boundary nodes, the optional parameter `NBoundVertex` must be set equal to the number of boundary nodes. By default, `NBoundVertex` equals zero, meaning that the nodes are unsorted. <p> Note that a non-zero value for `NBoundVertex` only applies to unstructured grids. For structured grids, the `NBoundVertex` parameter always equals 0 in all directions.<br><br> <table cellspacing=0 cellpadding=0 noborder>
    pub fn cg_zone_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        zonename: *mut ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `zonetype`(`ZoneType_t*`): undefined
    pub fn cg_zone_type(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        type_: *mut ZoneType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_zone_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        zone_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `zonename`(`char*`): Name of the zone.
    /// 
    /// &rarr; `size`(`cgsize_t*`): Number of vertices, cells, and boundary vertices in each (<i>index</i>)-dimension.  For structured grids, the dimensions have unit stride in the array (e.g., `[NVertexI, NVertexJ, NVertexK, NCellI, NCellJ, NCellK, NBoundVertexI, NBoundVertexJ, NBoundVertexK]`). <p> Note that for unstructured grids, the number of cells is the number of highest order elements. Thus, in three dimensions it's the number of 3-D cells, and in two dimensions it's the number of 2-D cells. <p> Also for unstructured grids, if the nodes are sorted between internal nodes and boundary nodes, the optional parameter `NBoundVertex` must be set equal to the number of boundary nodes. By default, `NBoundVertex` equals zero, meaning that the nodes are unsorted. <p> Note that a non-zero value for `NBoundVertex` only applies to unstructured grids. For structured grids, the `NBoundVertex` parameter always equals 0 in all directions.<br><br> <table cellspacing=0 cellpadding=0 noborder>
    /// 
    /// &rarr; `zonetype`(`ZoneType_t`): undefined
    /// 
    /// &larr; `Z`(`int*`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    pub fn cg_zone_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        zonename: *const ::std::os::raw::c_char,
        size: *const ::std::os::raw::c_int,
        type_: ZoneType_t,
        Z: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the index dimension for the CGNS zone
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `index_dim`(`int*`): undefined
    pub fn cg_index_dim(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        index_dim: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `nfamilies`(`int*`): Number of families in base `B`.
    pub fn cg_nfamilies(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        nfamilies: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &larr; `FamilyName`(`char*`): Name of the family.
    /// 
    /// &larr; `nFamBC`(`int*`): Number of boundary conditions for this family. This should be either 0 or 1.
    /// 
    /// &larr; `nGeo`(`int*`): Number of geometry references for this family.
    pub fn cg_family_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        family_name: *mut ::std::os::raw::c_char,
        nboco: *mut ::std::os::raw::c_int,
        ngeos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `FamilyName`(`char*`): Name of the family.
    /// 
    /// &larr; `Fam`(`int*`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    pub fn cg_family_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        family_name: *const ::std::os::raw::c_char,
        F: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &larr; `nNames`(`int*`): Number of `FamilyName_t` nodes for this family.
    pub fn cg_nfamily_names(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        nnames: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read multiple family names under Family_t
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `N`(`int`): Family name index number, where 1 &le; `N` &le; `nNames`.
    /// 
    /// &larr; `NodeName`(`char*`): Name of the `FamilyName_t` node. `FamilyParent` is used to refer to the parent family of the `Family_t` node.
    /// 
    /// &larr; `FamilyName`(`char*`): Name of the family.
    pub fn cg_family_name_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        family: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `NodeName`(`char*`): Name of the `FamilyName_t` node. `FamilyParent` is used to refer to the parent family of the `Family_t` node.
    /// 
    /// &rarr; `FamilyName`(`char*`): Name of the family.
    pub fn cg_family_name_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        family: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_family_write(
        family_name: *const ::std::os::raw::c_char,
        F: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_nfamilies(nfamilies: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_family_read(
        F: ::std::os::raw::c_int,
        family_name: *mut ::std::os::raw::c_char,
        nFamBC: *mut ::std::os::raw::c_int,
        nGeo: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_family_name_write(
        node_name: *const ::std::os::raw::c_char,
        family_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_nfamily_names(nnames: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_family_name_read(
        N: ::std::os::raw::c_int,
        node_name: *mut ::std::os::raw::c_char,
        family_name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `FamilyName`(`char*`): Family name.
    pub fn cg_famname_read(family_name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `FamilyName`(`char*`): Family name.
    pub fn cg_famname_write(family_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `nNames`(`int*`): Number of additional family names.
    pub fn cg_nmultifam(nfams: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read multiple family names
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `N`(`int`): Family name index number, where 1 &le; `N` &le; `nNames`.
    /// 
    /// &larr; `NodeName`(`char*`): Node name.
    /// 
    /// &larr; `FamilyName`(`char*`): Family name.
    pub fn cg_multifam_read(
        N: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        family: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `NodeName`(`char*`): Node name.
    /// 
    /// &rarr; `FamilyName`(`char*`): Family name.
    pub fn cg_multifam_write(
        name: *const ::std::os::raw::c_char,
        family: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read boundary condition type for a family
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `BC`(`int`): Family boundary condition index number. This must be equal to 1.
    /// 
    /// &larr; `FamBCName`(`char*`): Name of the `FamilyBC_t` node.
    /// 
    /// &larr; `BCType`(`BCType_t*`): Boundary condition type for the family. See the eligible types for `BCType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section.
    pub fn cg_fambc_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        fambc_name: *mut ::std::os::raw::c_char,
        bocotype: *mut BCType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `FamBCName`(`char*`): Name of the `FamilyBC_t` node.
    /// 
    /// &rarr; `BCType`(`BCType_t`): Boundary condition type for the family. See the eligible types for `BCType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section.
    /// 
    /// &larr; `BC`(`int*`): Family boundary condition index number. This must be equal to 1.
    pub fn cg_fambc_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        fambc_name: *const ::std::os::raw::c_char,
        bocotype: BCType_t,
        BC: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_fambc_read(
        BC: ::std::os::raw::c_int,
        fambc_name: *mut ::std::os::raw::c_char,
        bocotype: *mut BCType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_fambc_write(
        fambc_name: *const ::std::os::raw::c_char,
        bocotype: BCType_t,
        BC: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `G`(`int`): Geometry reference index number, where 1 &le; `G` &le; `nGeo`.
    /// 
    /// &larr; `GeoName`(`char*`): Name of `GeometryReference_t` node.
    /// 
    /// &larr; `FileName`(`char**`): Name of geometry file.
    /// 
    /// &larr; `CADSystem`(`char*`): Geometry format.
    /// 
    /// &larr; `nparts`(`int*`): Number of geometry entities.
    pub fn cg_geo_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        G: ::std::os::raw::c_int,
        geo_name: *mut ::std::os::raw::c_char,
        geo_file: *mut *mut ::std::os::raw::c_char,
        CAD_name: *mut ::std::os::raw::c_char,
        npart: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `GeoName`(`char*`): Name of `GeometryReference_t` node.
    /// 
    /// &rarr; `FileName`(`char*`): Name of geometry file.
    /// 
    /// &rarr; `CADSystem`(`char*`): Geometry format.
    /// 
    /// &larr; `G`(`int*`): Geometry reference index number, where 1 &le; `G` &le; `nGeo`.
    pub fn cg_geo_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        geo_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        CADname: *const ::std::os::raw::c_char,
        G: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_geo_read(
        G: ::std::os::raw::c_int,
        geo_name: *mut ::std::os::raw::c_char,
        geo_file: *mut *mut ::std::os::raw::c_char,
        CAD_name: *mut ::std::os::raw::c_char,
        npart: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_geo_write(
        geo_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        CADname: *const ::std::os::raw::c_char,
        G: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get geometry entity name
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `G`(`int`): Geometry reference index number, where 1 &le; `G` &le; `nGeo`.
    /// 
    /// &rarr; `P`(`int`): Geometry entity index number, where 1 &le; `P` &le; `nparts`.
    /// 
    /// &larr; `PartName`(`char*`): Name of a geometry entity in the file `FileName`.
    pub fn cg_part_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        G: ::std::os::raw::c_int,
        P: ::std::os::raw::c_int,
        part_name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Fam`(`int`): Family index number, where 1 &le; `Fam` &le; `nfamilies`.
    /// 
    /// &rarr; `G`(`int`): Geometry reference index number, where 1 &le; `G` &le; `nGeo`.
    /// 
    /// &rarr; `PartName`(`char*`): Name of a geometry entity in the file `FileName`.
    /// 
    /// &larr; `P`(`int*`): Geometry entity index number, where 1 &le; `P` &le; `nparts`.
    pub fn cg_part_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        G: ::std::os::raw::c_int,
        part_name: *const ::std::os::raw::c_char,
        P: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_part_read(
        G: ::std::os::raw::c_int,
        P: ::std::os::raw::c_int,
        part_name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_node_part_write(
        G: ::std::os::raw::c_int,
        part_name: *const ::std::os::raw::c_char,
        P: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `ngrids`(`int*`): Number of `GridCoordinates_t` nodes for zone `Z`.
    pub fn cg_ngrids(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        ngrids: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `G`(`int`): Grid index number, where 1 &le; `G` &le; `ngrids`.
    /// 
    /// &larr; `GridCoordName`(`char*`): undefined
    pub fn cg_grid_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        G: ::std::os::raw::c_int,
        gridname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `GridCoordName`(`char*`): undefined
    /// 
    /// &larr; `G`(`int*`): Grid index number, where 1 &le; `G` &le; `ngrids`.
    pub fn cg_grid_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        zcoorname: *const ::std::os::raw::c_char,
        G: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_grid_bounding_box_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        G: ::std::os::raw::c_int,
        type_: DataType_t,
        boundingbox: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_grid_bounding_box_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        G: ::std::os::raw::c_int,
        type_: DataType_t,
        boundingbox: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `ncoords`(`int*`): Number of coordinate arrays for zone `Z`.
    pub fn cg_ncoords(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        ncoords: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `C`(`int`): Coordinate array index number, where 1 &le; `C` &le; `ncoords`.
    /// 
    /// &larr; `datatype`(`DataType_t*`): Data type of the coordinate array written to the file. Admissible data types for a coordinate array are `RealSingle` and `RealDouble`.
    /// 
    /// &larr; `coordname`(`char*`): Name of the coordinate array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_grid>SIDS nomenclature conventions</a> when naming the coordinate arrays to insure file compatibility.
    pub fn cg_coord_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        C: ::std::os::raw::c_int,
        type_: *mut DataType_t,
        coordname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `coordname`(`char*`): Name of the coordinate array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_grid>SIDS nomenclature conventions</a> when naming the coordinate arrays to insure file compatibility.
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): Data type of an array in memory. Admissible data types for a coordinate array are `RealSingle` and `RealDouble`..
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &larr; `coord_array`(`void*`): Array of coordinate values.
    pub fn cg_coord_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        coordname: *const ::std::os::raw::c_char,
        type_: DataType_t,
        rmin: *const ::std::os::raw::c_int,
        rmax: *const ::std::os::raw::c_int,
        coord: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read subset of grid coordinates to a shaped array
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `coordname`(`char*`): Name of the coordinate array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_grid>SIDS nomenclature conventions</a> when naming the coordinate arrays to insure file compatibility.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): Data type of an array in memory. Admissible data types for a coordinate array are `RealSingle` and `RealDouble`..
    /// 
    /// &rarr; `mem_rank`(`int`): Number of dimensions of array in memory.
    /// 
    /// &rarr; `mem_dimensions`(`cgsize_t*`): Dimensions of array in memory.
    /// 
    /// &rarr; `mem_range_min`(`cgsize_t*`): Lower range index in memory (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `mem_range_max`(`cgsize_t*`): Upper range index in memory (eg., `imax, jmax, kmax`).
    /// 
    /// &larr; `coord_array`(`void*`): Array of coordinate values.
    pub fn cg_coord_general_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        coordname: *const ::std::os::raw::c_char,
        s_rmin: *const ::std::os::raw::c_int,
        s_rmax: *const ::std::os::raw::c_int,
        m_type: DataType_t,
        m_numdim: ::std::os::raw::c_int,
        m_dimvals: *const ::std::os::raw::c_int,
        m_rmin: *const ::std::os::raw::c_int,
        m_rmax: *const ::std::os::raw::c_int,
        coord_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_coord_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        C: ::std::os::raw::c_int,
        coord_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Data type of the coordinate array written to the file. Admissible data types for a coordinate array are `RealSingle` and `RealDouble`.
    /// 
    /// &rarr; `coordname`(`char*`): Name of the coordinate array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_grid>SIDS nomenclature conventions</a> when naming the coordinate arrays to insure file compatibility.
    /// 
    /// &rarr; `coord_array`(`void*`): Array of coordinate values.
    /// 
    /// &larr; `C`(`int*`): Coordinate array index number, where 1 &le; `C` &le; `ncoords`.
    pub fn cg_coord_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        type_: DataType_t,
        coordname: *const ::std::os::raw::c_char,
        coord_ptr: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Data type of the coordinate array written to the file. Admissible data types for a coordinate array are `RealSingle` and `RealDouble`.
    /// 
    /// &rarr; `coordname`(`char*`): Name of the coordinate array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_grid>SIDS nomenclature conventions</a> when naming the coordinate arrays to insure file compatibility.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `coord_array`(`void*`): Array of coordinate values.
    /// 
    /// &larr; `C`(`int*`): Coordinate array index number, where 1 &le; `C` &le; `ncoords`.
    pub fn cg_coord_partial_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        type_: DataType_t,
        coordname: *const ::std::os::raw::c_char,
        rmin: *const ::std::os::raw::c_int,
        rmax: *const ::std::os::raw::c_int,
        coord_ptr: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `coordname`(`char*`): Name of the coordinate array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_grid>SIDS nomenclature conventions</a> when naming the coordinate arrays to insure file compatibility.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Data type of the coordinate array written to the file. Admissible data types for a coordinate array are `RealSingle` and `RealDouble`.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): Data type of an array in memory. Admissible data types for a coordinate array are `RealSingle` and `RealDouble`..
    /// 
    /// &rarr; `mem_rank`(`int`): Number of dimensions of array in memory.
    /// 
    /// &rarr; `mem_dimensions`(`cgsize_t*`): Dimensions of array in memory.
    /// 
    /// &rarr; `mem_range_min`(`cgsize_t*`): Lower range index in memory (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `mem_range_max`(`cgsize_t*`): Upper range index in memory (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `coord_array`(`void*`): Array of coordinate values.
    /// 
    /// &larr; `C`(`int*`): Coordinate array index number, where 1 &le; `C` &le; `ncoords`.
    pub fn cg_coord_general_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        coordname: *const ::std::os::raw::c_char,
        s_type: DataType_t,
        rmin: *const ::std::os::raw::c_int,
        rmax: *const ::std::os::raw::c_int,
        m_type: DataType_t,
        m_numdim: ::std::os::raw::c_int,
        m_dims: *const ::std::os::raw::c_int,
        m_rmin: *const ::std::os::raw::c_int,
        m_rmax: *const ::std::os::raw::c_int,
        coord_ptr: *const ::std::os::raw::c_void,
        C: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `nsections`(`int*`): Number of element sections.
    pub fn cg_nsections(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        nsections: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &larr; `ElementSectionName`(`char*`): Name of the `Elements_t` node.
    /// 
    /// &larr; `type`(`ElementType_t*`): Type of element. See the eligible types for `ElementType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section.
    /// 
    /// &larr; `start`(`cgsize_t*`): Index of first element in the section.
    /// 
    /// &larr; `end`(`cgsize_t*`): Index of last element in the section.
    /// 
    /// &larr; `nbndry`(`int*`): Index of last boundary element in the section. Set to zero if the elements are unsorted.
    /// 
    /// &larr; `parent_flag`(`int*`): Flag indicating if the parent data are defined. If the parent data exist, `parent_flag` is set to 1; otherwise it is set to 0.
    pub fn cg_section_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        SectionName: *mut ::std::os::raw::c_char,
        type_: *mut ElementType_t,
        start: *mut ::std::os::raw::c_int,
        end: *mut ::std::os::raw::c_int,
        nbndry: *mut ::std::os::raw::c_int,
        parent_flag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &larr; `Elements`(`cgsize_t*`): Element connectivity data. The element connectivity order is given in <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/conv.html#unstructgrid>Element Numbering Conventions</a>.
    /// 
    /// &larr; `ParentData`(`cgsize_t*`): For boundary or interface elements, this array contains information on the cell(s) and cell face(s) sharing the element. If you do not need to read the `ParentData` when reading the `ElementData`, you may set the value to `NULL`.
    pub fn cg_elements_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        elements: *mut ::std::os::raw::c_int,
        parent_data: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &larr; `Elements`(`cgsize_t*`): Element connectivity data. The element connectivity order is given in <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/conv.html#unstructgrid>Element Numbering Conventions</a>.
    /// 
    /// &larr; `ConnectOffset`(`cgsize_t*`): Element connectivity offset data. This is required for `NGON_n`, `NFACE_n` and `MIXED` according to <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/gridflow.html#Elements>Elements_t Structure Definition</a>.
    /// 
    /// &larr; `ParentData`(`cgsize_t*`): For boundary or interface elements, this array contains information on the cell(s) and cell face(s) sharing the element. If you do not need to read the `ParentData` when reading the `ElementData`, you may set the value to `NULL`.
    pub fn cg_poly_elements_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        elements: *mut ::std::os::raw::c_int,
        connect_offset: *mut ::std::os::raw::c_int,
        parent_data: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `ElementSectionName`(`char*`): Name of the `Elements_t` node.
    /// 
    /// &rarr; `type`(`ElementType_t`): Type of element. See the eligible types for `ElementType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section.
    /// 
    /// &rarr; `start`(`cgsize_t`): Index of first element in the section.
    /// 
    /// &rarr; `end`(`cgsize_t`): Index of last element in the section.
    /// 
    /// &rarr; `nbndry`(`int`): Index of last boundary element in the section. Set to zero if the elements are unsorted.
    /// 
    /// &rarr; `Elements`(`cgsize_t*`): Element connectivity data. The element connectivity order is given in <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/conv.html#unstructgrid>Element Numbering Conventions</a>.
    /// 
    /// &larr; `S`(`int*`): Element section index, where 1 &le; `S` &le; `nsections`.
    pub fn cg_section_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        SectionName: *const ::std::os::raw::c_char,
        type_: ElementType_t,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        nbndry: ::std::os::raw::c_int,
        elements: *const ::std::os::raw::c_int,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `ElementSectionName`(`char*`): Name of the `Elements_t` node.
    /// 
    /// &rarr; `type`(`ElementType_t`): Type of element. See the eligible types for `ElementType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section.
    /// 
    /// &rarr; `start`(`cgsize_t`): Index of first element in the section.
    /// 
    /// &rarr; `end`(`cgsize_t`): Index of last element in the section.
    /// 
    /// &rarr; `nbndry`(`int`): Index of last boundary element in the section. Set to zero if the elements are unsorted.
    /// 
    /// &rarr; `Elements`(`cgsize_t*`): Element connectivity data. The element connectivity order is given in <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/conv.html#unstructgrid>Element Numbering Conventions</a>.
    /// 
    /// &rarr; `ConnectOffset`(`cgsize_t*`): Element connectivity offset data. This is required for `NGON_n`, `NFACE_n` and `MIXED` according to <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/gridflow.html#Elements>Elements_t Structure Definition</a>.
    /// 
    /// &larr; `S`(`int*`): Element section index, where 1 &le; `S` &le; `nsections`.
    pub fn cg_poly_section_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        SectionName: *const ::std::os::raw::c_char,
        type_: ElementType_t,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        nbndry: ::std::os::raw::c_int,
        elements: *const ::std::os::raw::c_int,
        connect_offset: *const ::std::os::raw::c_int,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &rarr; `ParentData`(`cgsize_t*`): For boundary or interface elements, this array contains information on the cell(s) and cell face(s) sharing the element. If you do not need to read the `ParentData` when reading the `ElementData`, you may set the value to `NULL`.
    pub fn cg_parent_data_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        parent_data: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get number of nodes for an element type
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `type`(`ElementType_t`): Type of element. See the eligible types for `ElementType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section.
    /// 
    /// &larr; `npe`(`int*`): Number of nodes for an element of type `type`.
    pub fn cg_npe(type_: ElementType_t, npe: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &larr; `ElementDataSize`(`cgsize_t*`): Number of element connectivity data values.
    pub fn cg_ElementDataSize(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        ElementDataSize: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `ElementSectionName`(`char*`): Name of the `Elements_t` node.
    /// 
    /// &rarr; `type`(`ElementType_t`): Type of element. See the eligible types for `ElementType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section.
    /// 
    /// &rarr; `start`(`cgsize_t`): Index of first element in the section.
    /// 
    /// &rarr; `end`(`cgsize_t`): Index of last element in the section.
    /// 
    /// &rarr; `nbndry`(`int`): Index of last boundary element in the section. Set to zero if the elements are unsorted.
    /// 
    /// &larr; `S`(`int*`): Element section index, where 1 &le; `S` &le; `nsections`.
    pub fn cg_section_partial_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        SectionName: *const ::std::os::raw::c_char,
        type_: ElementType_t,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        nbndry: ::std::os::raw::c_int,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    pub fn cg_elements_partial_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        elements: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &rarr; `ConnectOffset`(`cgsize_t*`): Element connectivity offset data. This is required for `NGON_n`, `NFACE_n` and `MIXED` according to <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/gridflow.html#Elements>Elements_t Structure Definition</a>.
    pub fn cg_poly_elements_partial_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        elements: *const ::std::os::raw::c_int,
        connect_offset: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &rarr; `start`(`cgsize_t`): Index of first element in the section.
    /// 
    /// &rarr; `end`(`cgsize_t`): Index of last element in the section.
    /// 
    /// &rarr; `ParentData`(`cgsize_t*`): For boundary or interface elements, this array contains information on the cell(s) and cell face(s) sharing the element. If you do not need to read the `ParentData` when reading the `ElementData`, you may set the value to `NULL`.
    pub fn cg_parent_data_partial_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        ParentData: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &rarr; `start`(`cgsize_t`): Index of first element in the section.
    /// 
    /// &rarr; `end`(`cgsize_t`): Index of last element in the section.
    /// 
    /// &larr; `Elements`(`cgsize_t*`): Element connectivity data. The element connectivity order is given in <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/conv.html#unstructgrid>Element Numbering Conventions</a>.
    /// 
    /// &larr; `ParentData`(`cgsize_t*`): For boundary or interface elements, this array contains information on the cell(s) and cell face(s) sharing the element. If you do not need to read the `ParentData` when reading the `ElementData`, you may set the value to `NULL`.
    pub fn cg_elements_partial_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        elements: *mut ::std::os::raw::c_int,
        parent_data: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &rarr; `start`(`cgsize_t`): Index of first element in the section.
    /// 
    /// &rarr; `end`(`cgsize_t`): Index of last element in the section.
    /// 
    /// &larr; `Elements`(`cgsize_t*`): Element connectivity data. The element connectivity order is given in <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/conv.html#unstructgrid>Element Numbering Conventions</a>.
    /// 
    /// &larr; `ConnectOffset`(`cgsize_t*`): Element connectivity offset data. This is required for `NGON_n`, `NFACE_n` and `MIXED` according to <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/gridflow.html#Elements>Elements_t Structure Definition</a>.
    /// 
    /// &larr; `ParentData`(`cgsize_t*`): For boundary or interface elements, this array contains information on the cell(s) and cell face(s) sharing the element. If you do not need to read the `ParentData` when reading the `ElementData`, you may set the value to `NULL`.
    pub fn cg_poly_elements_partial_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        elements: *mut ::std::os::raw::c_int,
        connect_offset: *mut ::std::os::raw::c_int,
        parent_data: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Element section index, where 1 &le; `S` &le; `nsections`.
    /// 
    /// &rarr; `start`(`cgsize_t`): Index of first element in the section.
    /// 
    /// &rarr; `end`(`cgsize_t`): Index of last element in the section.
    /// 
    /// &larr; `ElementDataSize`(`cgsize_t*`): Number of element connectivity data values.
    pub fn cg_ElementPartialSize(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        ElementDataSize: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `nsols`(`int*`): Number of flow solutions for zone `Z`.
    pub fn cg_nsols(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        nsols: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &larr; `solname`(`char*`): Name of the flow solution.
    /// 
    /// &larr; `location`(`GridLocation_t*`): Grid location where the solution is recorded. The current admissible locations are `Vertex`, `CellCenter`, `IFaceCenter`, `JFaceCenter`, and `KFaceCenter`.
    pub fn cg_sol_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        solname: *mut ::std::os::raw::c_char,
        location: *mut GridLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_sol_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        sol_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `solname`(`char*`): Name of the flow solution.
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location where the solution is recorded. The current admissible locations are `Vertex`, `CellCenter`, `IFaceCenter`, `JFaceCenter`, and `KFaceCenter`.
    /// 
    /// &larr; `S`(`int*`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    pub fn cg_sol_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        solname: *const ::std::os::raw::c_char,
        location: GridLocation_t,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &larr; `data_dim`(`int*`): Number of dimensions defining the solution data. If a point set has been defined, this will be 1, otherwise this will be the current zone index dimension.</td>
    /// 
    /// &larr; `dim_vals`(`cgsize_t*`): The array of `data_dim` dimensions for the solution data.</td>
    pub fn cg_sol_size(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        data_dim: *mut ::std::os::raw::c_int,
        dim_vals: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &larr; `ptset_type`(`PointSetType_t*`): Type of point set defining the interface in the current solution; either `PointRange` or `PointList`.
    /// 
    /// &larr; `npnts`(`cgsize_t*`): Number of points defining the interface in the current solution. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the `PointList`.
    pub fn cg_sol_ptset_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        ptset_type: *mut PointSetType_t,
        npnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &larr; `pnts`(`cgsize_t*`): Array of points defining the interface in the current solution.
    pub fn cg_sol_ptset_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        pnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location where the solution is recorded. The current admissible locations are `Vertex`, `CellCenter`, `IFaceCenter`, `JFaceCenter`, and `KFaceCenter`.
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): Type of point set defining the interface in the current solution; either `PointRange` or `PointList`.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): Number of points defining the interface in the current solution. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the `PointList`.
    /// 
    /// &rarr; `cgsize_t `(`const`): undefined
    /// 
    /// &larr; `S`(`int*`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    pub fn cg_sol_ptset_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        solname: *const ::std::os::raw::c_char,
        location: GridLocation_t,
        ptset_type: PointSetType_t,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &larr; `nfields`(`int*`): Number of data arrays in flow solution `S`.
    pub fn cg_nfields(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        nfields: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &rarr; `F`(`int`): Solution array index number, where 1 &le; `F` &le; `nfields`.
    /// 
    /// &larr; `datatype`(`DataType_t*`): Data type of the solution array written to the file. Admissible data types for a solution array are `Integer`, `LongInteger`, `RealSingle`, and `RealDouble`.
    /// 
    /// &larr; `fieldname`(`char*`): Name of the solution array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_flow>SIDS nomenclature conventions</a> when naming the solution arrays to insure file compatibility.
    pub fn cg_field_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        type_: *mut DataType_t,
        fieldname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &rarr; `fieldname`(`char*`): Name of the solution array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_flow>SIDS nomenclature conventions</a> when naming the solution arrays to insure file compatibility.
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): Data type of an array in memory. Admissible data types for a solution array are `Integer`, `LongInteger`, `RealSingle`, and `RealDouble`.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &larr; `solution_array`(`void*`): Array of solution values.
    pub fn cg_field_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        fieldname: *const ::std::os::raw::c_char,
        type_: DataType_t,
        rmin: *const ::std::os::raw::c_int,
        rmax: *const ::std::os::raw::c_int,
        field_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read subset of flow solution to a shaped array
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &rarr; `fieldname`(`char*`): Name of the solution array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_flow>SIDS nomenclature conventions</a> when naming the solution arrays to insure file compatibility.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): Data type of an array in memory. Admissible data types for a solution array are `Integer`, `LongInteger`, `RealSingle`, and `RealDouble`.
    /// 
    /// &rarr; `mem_rank`(`int`): Number of dimensions of array in memory.
    /// 
    /// &rarr; `mem_dimensions`(`cgsize_t*`): Dimensions of array in memory.
    /// 
    /// &rarr; `mem_range_min`(`cgsize_t*`): Lower range index in memory (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `mem_range_max`(`cgsize_t*`): Upper range index in memory (eg., `imax, jmax, kmax`).
    /// 
    /// &larr; `solution_array`(`void*`): Array of solution values.
    pub fn cg_field_general_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        fieldname: *const ::std::os::raw::c_char,
        s_rmin: *const ::std::os::raw::c_int,
        s_rmax: *const ::std::os::raw::c_int,
        m_type: DataType_t,
        m_numdim: ::std::os::raw::c_int,
        m_dimvals: *const ::std::os::raw::c_int,
        m_rmin: *const ::std::os::raw::c_int,
        m_rmax: *const ::std::os::raw::c_int,
        field_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_field_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        F: ::std::os::raw::c_int,
        field_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Data type of the solution array written to the file. Admissible data types for a solution array are `Integer`, `LongInteger`, `RealSingle`, and `RealDouble`.
    /// 
    /// &rarr; `fieldname`(`char*`): Name of the solution array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_flow>SIDS nomenclature conventions</a> when naming the solution arrays to insure file compatibility.
    /// 
    /// &rarr; `solution_array`(`void*`): Array of solution values.
    /// 
    /// &larr; `F`(`int*`): Solution array index number, where 1 &le; `F` &le; `nfields`.
    pub fn cg_field_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        type_: DataType_t,
        fieldname: *const ::std::os::raw::c_char,
        field_ptr: *const ::std::os::raw::c_void,
        F: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Data type of the solution array written to the file. Admissible data types for a solution array are `Integer`, `LongInteger`, `RealSingle`, and `RealDouble`.
    /// 
    /// &rarr; `fieldname`(`char*`): Name of the solution array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_flow>SIDS nomenclature conventions</a> when naming the solution arrays to insure file compatibility.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `solution_array`(`void*`): Array of solution values.
    /// 
    /// &larr; `F`(`int*`): Solution array index number, where 1 &le; `F` &le; `nfields`.
    pub fn cg_field_partial_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        type_: DataType_t,
        fieldname: *const ::std::os::raw::c_char,
        rmin: *const ::std::os::raw::c_int,
        rmax: *const ::std::os::raw::c_int,
        field_ptr: *const ::std::os::raw::c_void,
        F: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): Flow solution index number, where 1 &le; `S` &le; `nsols`.
    /// 
    /// &rarr; `fieldname`(`char*`): Name of the solution array. It is strongly advised to use the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/dataname.html#dataname_flow>SIDS nomenclature conventions</a> when naming the solution arrays to insure file compatibility.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Data type of the solution array written to the file. Admissible data types for a solution array are `Integer`, `LongInteger`, `RealSingle`, and `RealDouble`.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): Data type of an array in memory. Admissible data types for a solution array are `Integer`, `LongInteger`, `RealSingle`, and `RealDouble`.
    /// 
    /// &rarr; `mem_rank`(`int`): Number of dimensions of array in memory.
    /// 
    /// &rarr; `mem_dimensions`(`cgsize_t*`): Dimensions of array in memory.
    /// 
    /// &rarr; `mem_range_min`(`cgsize_t*`): Lower range index in memory (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `mem_range_max`(`cgsize_t*`): Upper range index in memory (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `solution_array`(`void*`): Array of solution values.
    /// 
    /// &larr; `F`(`int*`): Solution array index number, where 1 &le; `F` &le; `nfields`.
    pub fn cg_field_general_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        fieldname: *const ::std::os::raw::c_char,
        s_type: DataType_t,
        rmin: *const ::std::os::raw::c_int,
        rmax: *const ::std::os::raw::c_int,
        m_type: DataType_t,
        m_numdim: ::std::os::raw::c_int,
        m_dims: *const ::std::os::raw::c_int,
        m_rmin: *const ::std::os::raw::c_int,
        m_rmax: *const ::std::os::raw::c_int,
        field_ptr: *const ::std::os::raw::c_void,
        F: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `nsubregs`(`int*`): Number of `ZoneSubRegion_t` nodes under Zone `Z`.
    pub fn cg_nsubregs(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        nsubreg: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): ZoneSubRegion index number, where 1 &le; `S` &le; `nsubregs`.
    /// 
    /// &larr; `regname`(`char*`): Name of the <zz>ZoneSubRegion_t</tt> node,</td>
    /// 
    /// &larr; `dimension`(`int*`): Dimensionality of the subregion, 1 for lines, 2 for faces, 3 for volumes,</td>
    /// 
    /// &larr; `location`(`GridLocation_t*`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` and `CellCenter`.
    /// 
    /// &larr; `ptset_type`(`PointSetType_t*`): Type of point set defining the interface for the subregion data; either `PointRange` or `PointList`.
    /// 
    /// &larr; `npnts`(`cgsize_t*`): Number of points defining the interface for the subregion data. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the `PointList`.
    /// 
    /// &larr; `bcname_len`(`int*`): String length of `bcname`.</td>
    /// 
    /// &larr; `gcname_len`(`int*`): String length of `gcname`.</td>
    pub fn cg_subreg_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        regname: *mut ::std::os::raw::c_char,
        dimension: *mut ::std::os::raw::c_int,
        location: *mut GridLocation_t,
        ptset_type: *mut PointSetType_t,
        npnts: *mut ::std::os::raw::c_int,
        bcname_len: *mut ::std::os::raw::c_int,
        gcname_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): ZoneSubRegion index number, where 1 &le; `S` &le; `nsubregs`.
    /// 
    /// &larr; `pnts`(`cgsize_t*`): Array of points defining the interface  for the subregion data.
    pub fn cg_subreg_ptset_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        pnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): ZoneSubRegion index number, where 1 &le; `S` &le; `nsubregs`.
    /// 
    /// &larr; `bcname`(`char*`): The name of a `BC_t` node which defines the subregion.</td>
    pub fn cg_subreg_bcname_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        bcname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `S`(`int`): ZoneSubRegion index number, where 1 &le; `S` &le; `nsubregs`.
    /// 
    /// &larr; `gcname`(`char*`): The name of a `GridConnectivity_t` or `GridConnectivity1to1_t` node which defines the subregion.</td>
    pub fn cg_subreg_gcname_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        S: ::std::os::raw::c_int,
        gcname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &rarr; `dimension`(`int`): Dimensionality of the subregion, 1 for lines, 2 for faces, 3 for volumes,</td>
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` and `CellCenter`.
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): Type of point set defining the interface for the subregion data; either `PointRange` or `PointList`.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): Number of points defining the interface for the subregion data. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the `PointList`.
    /// 
    /// &rarr; `cgsize_t `(`const`): undefined
    /// 
    /// &larr; `S`(`int*`): ZoneSubRegion index number, where 1 &le; `S` &le; `nsubregs`.
    pub fn cg_subreg_ptset_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        regname: *const ::std::os::raw::c_char,
        dimension: ::std::os::raw::c_int,
        location: GridLocation_t,
        ptset_type: PointSetType_t,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &rarr; `dimension`(`int`): Dimensionality of the subregion, 1 for lines, 2 for faces, 3 for volumes,</td>
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &larr; `S`(`int*`): ZoneSubRegion index number, where 1 &le; `S` &le; `nsubregs`.
    pub fn cg_subreg_bcname_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        regname: *const ::std::os::raw::c_char,
        dimension: ::std::os::raw::c_int,
        bcname: *const ::std::os::raw::c_char,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &rarr; `dimension`(`int`): Dimensionality of the subregion, 1 for lines, 2 for faces, 3 for volumes,</td>
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &larr; `S`(`int*`): ZoneSubRegion index number, where 1 &le; `S` &le; `nsubregs`.
    pub fn cg_subreg_gcname_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        regname: *const ::std::os::raw::c_char,
        dimension: ::std::os::raw::c_int,
        gcname: *const ::std::os::raw::c_char,
        S: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `nzconns`(`int*`): Number of `ZoneGridConnectivity_t` nodes under Zone `Z`.
    pub fn cg_nzconns(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        nzconns: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `ZC`(`int`): Zone grid connectivity index number, where 1 &le; `ZC` &le; `nzconns`.
    /// 
    /// &larr; `zcname`(`char*`): Name of the `ZoneGridConnectivity_t` node,</td>
    pub fn cg_zconn_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        C: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &larr; `ZC`(`int*`): Zone grid connectivity index number, where 1 &le; `ZC` &le; `nzconns`.
    pub fn cg_zconn_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        C: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `ZC`(`int*`): Zone grid connectivity index number, where 1 &le; `ZC` &le; `nzconns`.
    pub fn cg_zconn_get(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        C: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `ZC`(`int`): Zone grid connectivity index number, where 1 &le; `ZC` &le; `nzconns`.
    pub fn cg_zconn_set(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        C: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `nholes`(`int*`): Number of overset holes in zone `Z`.
    pub fn cg_nholes(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        nholes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Overset hole index number, where 1 &le; `I` &le; `nholes`.
    /// 
    /// &larr; `holename`(`char*`): Name of the overset hole.
    /// 
    /// &larr; `location`(`GridLocation_t*`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` and `CellCenter`.
    /// 
    /// &larr; `ptset_type`(`PointSetType_t*`): The extent of the overset hole may be defined using a range of points or cells, or using a discrete list of all points or cells in the overset hole. If a range of points or cells is used, `ptset_type` is set to `PointRange`. When a discrete list of points or cells is used, `ptset_type` equals `PointList`.
    /// 
    /// &larr; `nptsets`(`int*`): Number of point sets used to define the hole. If `ptset_type` is `PointRange`, several point sets may be used. If `ptset_type` is `PointList`, only one point set is allowed.
    /// 
    /// &larr; `npnts`(`cgsize_t*`): Number of points (or cells) in the point set. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points or cells in the `PointList`.
    pub fn cg_hole_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        holename: *mut ::std::os::raw::c_char,
        location: *mut GridLocation_t,
        ptset_type: *mut PointSetType_t,
        nptsets: *mut ::std::os::raw::c_int,
        npnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read overset hole data
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Overset hole index number, where 1 &le; `I` &le; `nholes`.
    /// 
    /// &larr; `pnts`(`cgsize_t*`): Array of points or cells in the point set.
    pub fn cg_hole_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        pnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_hole_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        hole_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `holename`(`char*`): Name of the overset hole.
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` and `CellCenter`.
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): The extent of the overset hole may be defined using a range of points or cells, or using a discrete list of all points or cells in the overset hole. If a range of points or cells is used, `ptset_type` is set to `PointRange`. When a discrete list of points or cells is used, `ptset_type` equals `PointList`.
    /// 
    /// &rarr; `nptsets`(`int`): Number of point sets used to define the hole. If `ptset_type` is `PointRange`, several point sets may be used. If `ptset_type` is `PointList`, only one point set is allowed.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): Number of points (or cells) in the point set. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points or cells in the `PointList`.
    /// 
    /// &rarr; `pnts`(`cgsize_t*`): Array of points or cells in the point set.
    /// 
    /// &larr; `I`(`int*`): Overset hole index number, where 1 &le; `I` &le; `nholes`.
    pub fn cg_hole_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        holename: *const ::std::os::raw::c_char,
        location: GridLocation_t,
        ptset_type: PointSetType_t,
        nptsets: ::std::os::raw::c_int,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
        Ii: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `nconns`(`int*`): Number of interfaces for zone `Z`.
    pub fn cg_nconns(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        nconns: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Interface index number, where 1 &le; `I` &le; `nconns`.
    /// 
    /// &larr; `connectname`(`char*`): Name of the interface.
    /// 
    /// &larr; `location`(`GridLocation_t*`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` and `CellCenter`.
    /// 
    /// &larr; `connect_type`(`GridConnectivityType_t*`): Type of interface being defined. The admissible types are `Overset`, `Abutting`, and `Abutting1to1`.
    /// 
    /// &larr; `ptset_type`(`PointSetType_t*`): Type of point set defining the interface in the current zone; either `PointRange` or `PointList`.
    /// 
    /// &larr; `npnts`(`cgsize_t*`): Number of points defining the interface in the current zone. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the `PointList`.
    /// 
    /// &larr; `donorname`(`char*`): Name of the zone interfacing with the current zone.
    /// 
    /// &larr; `donor_zonetype`(`ZoneType_t*`): Type of the donor zone. The admissible types are `Structured` and `Unstructured`.
    /// 
    /// &larr; `donor_ptset_type`(`PointSetType_t*`): Type of point set defining the interface in the donor zone; either `PointListDonor` or `CellListDonor`.
    /// 
    /// &larr; `donor_datatype`(`DataType_t*`): Data type in which the donor points are stored in the file. As of Version 3.0, this value is ignored when writing, and on reading it will return either `Integer` or `LongInteger` depending on whether the file was written using 32 or 64-bit. The `donor_datatype` argument was left in these functions only for backward compatibility. The donor data is always read as `cgsize_t`.
    /// 
    /// &larr; `ndata_donor`(`cgsize_t*`): Number of points or cells in the current zone. These are paired with points, cells, or fractions thereof in the donor zone.
    pub fn cg_conn_info(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        connectname: *mut ::std::os::raw::c_char,
        location: *mut GridLocation_t,
        type_: *mut GridConnectivityType_t,
        ptset_type: *mut PointSetType_t,
        npnts: *mut ::std::os::raw::c_int,
        donorname: *mut ::std::os::raw::c_char,
        donor_zonetype: *mut ZoneType_t,
        donor_ptset_type: *mut PointSetType_t,
        donor_datatype: *mut DataType_t,
        ndata_donor: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read generalized connectivity data
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Interface index number, where 1 &le; `I` &le; `nconns`.
    /// 
    /// &larr; `pnts`(`cgsize_t*`): Array of points defining the interface in the current zone.
    /// 
    /// &rarr; `donor_datatype`(`DataType_t`): Data type in which the donor points are stored in the file. As of Version 3.0, this value is ignored when writing, and on reading it will return either `Integer` or `LongInteger` depending on whether the file was written using 32 or 64-bit. The `donor_datatype` argument was left in these functions only for backward compatibility. The donor data is always read as `cgsize_t`.
    /// 
    /// &larr; `donor_data`(`cgsize_t*`): Array of donor points or cells corresponding to `ndata_donor`. Note that it is possible that the same donor point or cell may be used multiple times.
    pub fn cg_conn_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        pnts: *mut ::std::os::raw::c_int,
        donor_datatype: DataType_t,
        donor_data: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_conn_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        conn_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `connectname`(`char*`): Name of the interface.
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` and `CellCenter`.
    /// 
    /// &rarr; `connect_type`(`GridConnectivityType_t`): Type of interface being defined. The admissible types are `Overset`, `Abutting`, and `Abutting1to1`.
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): Type of point set defining the interface in the current zone; either `PointRange` or `PointList`.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): Number of points defining the interface in the current zone. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the `PointList`.
    /// 
    /// &rarr; `pnts`(`cgsize_t*`): Array of points defining the interface in the current zone.
    /// 
    /// &rarr; `donorname`(`char*`): Name of the zone interfacing with the current zone.
    /// 
    /// &rarr; `donor_zonetype`(`ZoneType_t`): Type of the donor zone. The admissible types are `Structured` and `Unstructured`.
    /// 
    /// &rarr; `donor_ptset_type`(`PointSetType_t`): Type of point set defining the interface in the donor zone; either `PointListDonor` or `CellListDonor`.
    /// 
    /// &rarr; `donor_datatype`(`DataType_t`): Data type in which the donor points are stored in the file. As of Version 3.0, this value is ignored when writing, and on reading it will return either `Integer` or `LongInteger` depending on whether the file was written using 32 or 64-bit. The `donor_datatype` argument was left in these functions only for backward compatibility. The donor data is always read as `cgsize_t`.
    /// 
    /// &rarr; `ndata_donor`(`cgsize_t`): Number of points or cells in the current zone. These are paired with points, cells, or fractions thereof in the donor zone.
    /// 
    /// &rarr; `donor_data`(`cgsize_t*`): Array of donor points or cells corresponding to `ndata_donor`. Note that it is possible that the same donor point or cell may be used multiple times.
    /// 
    /// &larr; `I`(`int*`): Interface index number, where 1 &le; `I` &le; `nconns`.
    pub fn cg_conn_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        connectname: *const ::std::os::raw::c_char,
        location: GridLocation_t,
        type_: GridConnectivityType_t,
        ptset_type: PointSetType_t,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
        donorname: *const ::std::os::raw::c_char,
        donor_zonetype: ZoneType_t,
        donor_ptset_type: PointSetType_t,
        donor_datatype: DataType_t,
        ndata_donor: ::std::os::raw::c_int,
        donor_data: *const ::std::os::raw::c_int,
        Ii: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `connectname`(`char*`): Name of the interface.
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` and `CellCenter`.
    /// 
    /// &rarr; `connect_type`(`GridConnectivityType_t`): Type of interface being defined. The admissible types are `Overset`, `Abutting`, and `Abutting1to1`.
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): Type of point set defining the interface in the current zone; either `PointRange` or `PointList`.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): Number of points defining the interface in the current zone. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the `PointList`.
    /// 
    /// &rarr; `pnts`(`cgsize_t*`): Array of points defining the interface in the current zone.
    /// 
    /// &rarr; `donorname`(`char*`): Name of the zone interfacing with the current zone.
    /// 
    /// &larr; `I`(`int*`): Interface index number, where 1 &le; `I` &le; `nconns`.
    pub fn cg_conn_write_short(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        connectname: *const ::std::os::raw::c_char,
        location: GridLocation_t,
        type_: GridConnectivityType_t,
        ptset_type: PointSetType_t,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
        donorname: *const ::std::os::raw::c_char,
        Ii: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Interface index number, where 1 &le; `I` &le; `nconns`.
    /// 
    /// &larr; `pnts`(`cgsize_t*`): Array of points defining the interface in the current zone.
    pub fn cg_conn_read_short(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        pnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `n1to1`(`int*`): Number of one-to-one interfaces in zone `Z`, stored under `GridConnectivity1to1_t` nodes. (I.e., this does not include one-to-one interfaces that may be stored under `GridConnectivity_t` nodes, used for generalized zone interfaces.)
    pub fn cg_n1to1(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        n1to1: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read 1-to-1 connectivity data for a zone
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Interface index number, where 1 &le; `I` &le; `n1to1`.
    /// 
    /// &larr; `connectname`(`char*`): Name of the interface.
    /// 
    /// &larr; `donorname`(`char*`): Name of the zone interfacing with the current zone.
    /// 
    /// &larr; `range`(`cgsize_t*`): Range of points for the current zone.
    /// 
    /// &larr; `donor_range`(`cgsize_t*`): Range of points for the donor zone.
    /// 
    /// &larr; `transform`(`int*`): Short hand notation for the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/cnct.html#Transform>transformation matrix</a> defining the relative orientation of the two zones.
    pub fn cg_1to1_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        connectname: *mut ::std::os::raw::c_char,
        donorname: *mut ::std::os::raw::c_char,
        range: *mut ::std::os::raw::c_int,
        donor_range: *mut ::std::os::raw::c_int,
        transform: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_1to1_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        one21_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `connectname`(`char*`): Name of the interface.
    /// 
    /// &rarr; `donorname`(`char*`): Name of the zone interfacing with the current zone.
    /// 
    /// &rarr; `range`(`cgsize_t*`): Range of points for the current zone.
    /// 
    /// &rarr; `donor_range`(`cgsize_t*`): Range of points for the donor zone.
    /// 
    /// &rarr; `transform`(`int*`): Short hand notation for the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/cnct.html#Transform>transformation matrix</a> defining the relative orientation of the two zones.
    /// 
    /// &larr; `I`(`int*`): Interface index number, where 1 &le; `I` &le; `n1to1`.
    pub fn cg_1to1_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        connectname: *const ::std::os::raw::c_char,
        donorname: *const ::std::os::raw::c_char,
        range: *const ::std::os::raw::c_int,
        donor_range: *const ::std::os::raw::c_int,
        transform: *const ::std::os::raw::c_int,
        Ii: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `n1to1_global`(`int*`): Total number of one-to-one interfaces in base `B`, stored under `GridConnectivity1to1_t` nodes. (I.e., this does not include one-to-one interfaces that may be stored under `GridConnectivity_t` nodes, used for generalized zone interfaces.) Note that the function `cg_n1to1` (described below) may be used to get the number of one-to-one interfaces in a specific zone.
    pub fn cg_n1to1_global(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        n1to1_global: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `connectname`(`char**`): Name of the interface.
    /// 
    /// &larr; `zonename`(`char**`): Name of the first zone, for all one-to-one interfaces in base `B`.
    /// 
    /// &larr; `donorname`(`char**`): Name of the second zone, for all one-to-one interfaces in base `B`.
    /// 
    /// &larr; `range`(`cgsize_t**`): Range of points for the first zone, for all one-to-one interfaces in base `B`.
    /// 
    /// &larr; `donor_range`(`cgsize_t**`): Range of points for the current zone, for all one-to-one interfaces in base `B`.
    /// 
    /// &larr; `transform`(`int**`): Short hand notation for the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/cnct.html#Transform>transformation matrix</a> defining the relative orientation of the two zones. This transformation is given for all one-to-one interfaces in base `B`.
    pub fn cg_1to1_read_global(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        connectname: *mut *mut ::std::os::raw::c_char,
        zonename: *mut *mut ::std::os::raw::c_char,
        donorname: *mut *mut ::std::os::raw::c_char,
        range: *mut *mut ::std::os::raw::c_int,
        donor_range: *mut *mut ::std::os::raw::c_int,
        transform: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `nbocos`(`int*`): Number of boundary conditions in zone `Z`.
    pub fn cg_nbocos(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        nbocos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &larr; `boconame`(`char*`): Name of the boundary condition.
    /// 
    /// &larr; `bocotype`(`BCType_t*`): Type of boundary condition defined. See the eligible types for `BCType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section. Note that if `bocotype` is `FamilySpecified` the boundary condition type is being specified for the family to which the boundary belongs. The boundary condition type for the family may be read and written using <a href=https://cgns.github.io/CGNS_docs_current/midlevel/families.html#familybc>`cg_fambc_read` and `cg_fambc_write`</a>.
    /// 
    /// &larr; `ptset_type`(`PointSetType_t*`): The extent of the boundary condition may be defined using a range of points or elements using `PointRange`, or using a discrete list of all points or elements at which the boundary condition is applied using `PointList`. When the boundary condition is to be applied anywhere other than points, then `GridLocation_t` under the `BC_t` node must be used to indicate this. The value of `GridLocation_t` may be read or written by `cg_boco_gridlocation_read` and `cg_boco_gridlocation_write`. As in previous versions of the library, this may also be done by first using <a href=https://cgns.github.io/CGNS_docs_current/midlevel/navigating.html#goto>`cg_goto`</a> to access the `BC_t` node, then using <a href=https://cgns.github.io/CGNS_docs_current/midlevel/location.html#gridlocation>`cg_gridlocation_read`</a> or <a href=https://cgns.github.io/CGNS_docs_current/midlevel/location.html#gridlocation>`cg_gridlocation_write`</a>.
    /// 
    /// &larr; `npnts`(`cgsize_t*`): Number of points or elements defining the boundary condition region. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points or elements in the list.
    /// 
    /// &larr; `NormalIndex`(`int*`): Index vector indicating the computational coordinate direction of the boundary condition patch normal.
    /// 
    /// &larr; `NormalListSize`(`cgsize_t*`): If the normals are defined in `NormalList`, `NormalListSize` is the number of points in the patch times `phys_dim`, the number of coordinates required to define a vector in the field. If the normals are not defined in `NormalList`, `NormalListSize` is 0.
    /// 
    /// &larr; `NormalDataType`(`DataType_t*`): Data type used in the definition of the normals. Admissible data types for the normals are `RealSingle` and `RealDouble`.
    /// 
    /// &larr; `ndataset`(`int*`): Number of boundary condition datasets for the current boundary condition.
    pub fn cg_boco_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        boconame: *mut ::std::os::raw::c_char,
        bocotype: *mut BCType_t,
        ptset_type: *mut PointSetType_t,
        npnts: *mut ::std::os::raw::c_int,
        NormalIndex: *mut ::std::os::raw::c_int,
        NormalListSize: *mut ::std::os::raw::c_int,
        NormalDataType: *mut DataType_t,
        ndataset: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &larr; `pnts`(`cgsize_t*`): Array of point or element indices defining the boundary condition region. There should be `npnts` values, each of dimension <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/cgnsbase.html#IndexDimension>`IndexDimension`</a> (i.e., 1 for unstructured grids, and 2 or 3 for structured grids with 2-D or 3-D elements, respectively).
    /// 
    /// &larr; `NormalList`(`void*`): List of vectors normal to the boundary condition patch pointing into the interior of the zone.
    pub fn cg_boco_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        pnts: *mut ::std::os::raw::c_int,
        NormalList: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_boco_id(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        boco_id: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `boconame`(`char*`): Name of the boundary condition.
    /// 
    /// &rarr; `bocotype`(`BCType_t`): Type of boundary condition defined. See the eligible types for `BCType_t` in the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/general.html#typedefs>Typedefs</a> section. Note that if `bocotype` is `FamilySpecified` the boundary condition type is being specified for the family to which the boundary belongs. The boundary condition type for the family may be read and written using <a href=https://cgns.github.io/CGNS_docs_current/midlevel/families.html#familybc>`cg_fambc_read` and `cg_fambc_write`</a>.
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): The extent of the boundary condition may be defined using a range of points or elements using `PointRange`, or using a discrete list of all points or elements at which the boundary condition is applied using `PointList`. When the boundary condition is to be applied anywhere other than points, then `GridLocation_t` under the `BC_t` node must be used to indicate this. The value of `GridLocation_t` may be read or written by `cg_boco_gridlocation_read` and `cg_boco_gridlocation_write`. As in previous versions of the library, this may also be done by first using <a href=https://cgns.github.io/CGNS_docs_current/midlevel/navigating.html#goto>`cg_goto`</a> to access the `BC_t` node, then using <a href=https://cgns.github.io/CGNS_docs_current/midlevel/location.html#gridlocation>`cg_gridlocation_read`</a> or <a href=https://cgns.github.io/CGNS_docs_current/midlevel/location.html#gridlocation>`cg_gridlocation_write`</a>.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): Number of points or elements defining the boundary condition region. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points or elements in the list.
    /// 
    /// &rarr; `pnts`(`cgsize_t*`): Array of point or element indices defining the boundary condition region. There should be `npnts` values, each of dimension <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/cgnsbase.html#IndexDimension>`IndexDimension`</a> (i.e., 1 for unstructured grids, and 2 or 3 for structured grids with 2-D or 3-D elements, respectively).
    /// 
    /// &larr; `BC`(`int*`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    pub fn cg_boco_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        boconame: *const ::std::os::raw::c_char,
        bocotype: BCType_t,
        ptset_type: PointSetType_t,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
        BC: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &rarr; `NormalIndex`(`int*`): Index vector indicating the computational coordinate direction of the boundary condition patch normal.
    /// 
    /// &rarr; `NormalListFlag`(`int`): Flag indicating if the normals are defined in `NormalList` and are to be written out; 1 if they are defined, 0 if they're not.
    /// 
    /// &rarr; `NormalDataType`(`DataType_t`): Data type used in the definition of the normals. Admissible data types for the normals are `RealSingle` and `RealDouble`.
    /// 
    /// &rarr; `NormalList`(`void*`): List of vectors normal to the boundary condition patch pointing into the interior of the zone.
    pub fn cg_boco_normal_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        NormalIndex: *const ::std::os::raw::c_int,
        NormalListFlag: ::std::os::raw::c_int,
        NormalDataType: DataType_t,
        NormalList: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read boundary condition location
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &larr; `location`(`GridLocation_t*`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` (the default if not given), and `CellCenter`. Interpretation of `CellCenter`, and additional allowable values of grid location depends on the base cell dimension. For `CellDim`=1, `CellCenter` refers to line elements. For `CellDim`=2, `CellCenter` refers to area elements, and the additional value `EdgeCenter` is allowed. For `CellDim`=3, `CellCenter` refers to volume elements, and in addition to `EdgeCenter`, the values of `FaceCenter`, `IFaceCenter`, `JFaceCenter`, and `KFaceCenter` may be used.
    pub fn cg_boco_gridlocation_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        location: *mut GridLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location used in the definition of the point set. The currently admissible locations are `Vertex` (the default if not given), and `CellCenter`. Interpretation of `CellCenter`, and additional allowable values of grid location depends on the base cell dimension. For `CellDim`=1, `CellCenter` refers to line elements. For `CellDim`=2, `CellCenter` refers to area elements, and the additional value `EdgeCenter` is allowed. For `CellDim`=3, `CellCenter` refers to volume elements, and in addition to `EdgeCenter`, the values of `FaceCenter`, `IFaceCenter`, `JFaceCenter`, and `KFaceCenter` may be used.
    pub fn cg_boco_gridlocation_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        location: GridLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &rarr; `Dset`(`int`): Dataset index number, where 1 &le; `Dset` &le; `ndataset`.
    /// 
    /// &larr; `DatasetName`(`char*`): Name of dataset.
    /// 
    /// &larr; `BCType`(`BCType_t*`): Simple boundary condition type for the dataset. The supported types are listed in the table of <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/bc.html#t:BCTypeSimple>Simple Boundary Condition Types</a> in the SIDS manual, but note that `FamilySpecified` does not apply here.
    /// 
    /// &larr; `DirichletFlag`(`int*`): Flag indicating if the dataset contains Dirichlet data.
    /// 
    /// &larr; `NeumannFlag`(`int*`): Flag indicating if the dataset contains Neumann data.
    pub fn cg_dataset_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        DS: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        BCType: *mut BCType_t,
        DirichletFlag: *mut ::std::os::raw::c_int,
        NeumannFlag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &rarr; `DatasetName`(`char*`): Name of dataset.
    /// 
    /// &rarr; `BCType`(`BCType_t`): Simple boundary condition type for the dataset. The supported types are listed in the table of <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/bc.html#t:BCTypeSimple>Simple Boundary Condition Types</a> in the SIDS manual, but note that `FamilySpecified` does not apply here.
    /// 
    /// &larr; `Dset`(`int*`): Dataset index number, where 1 &le; `Dset` &le; `ndataset`.
    pub fn cg_dataset_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        BCType: BCType_t,
        Dset: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `DatasetName`(`char*`): Name of dataset.
    /// 
    /// &rarr; `BCType`(`BCType_t`): Simple boundary condition type for the dataset. The supported types are listed in the table of <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/bc.html#t:BCTypeSimple>Simple Boundary Condition Types</a> in the SIDS manual, but note that `FamilySpecified` does not apply here.
    /// 
    /// &rarr; `BCDataType`(`BCDataType_t`): Type of boundary condition in the dataset (i.e., for a `BCData_t` child node). Admissible types are `Dirichlet` and `Neumann`.
    pub fn cg_bcdataset_write(
        name: *const ::std::os::raw::c_char,
        BCType: BCType_t,
        BCDataType: BCDataType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `ndataset`(`int*`): Number of `BCDataSet` nodes under the current `FamilyBC_t` node.
    pub fn cg_bcdataset_info(n_dataset: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read family boundary condition dataset info
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `Dset`(`int`): Dataset index number, where 1 &le; `Dset` &le; `ndataset`.
    /// 
    /// &larr; `DatasetName`(`char*`): Name of dataset.
    /// 
    /// &larr; `BCType`(`BCType_t*`): Simple boundary condition type for the dataset. The supported types are listed in the table of <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/bc.html#t:BCTypeSimple>Simple Boundary Condition Types</a> in the SIDS manual, but note that `FamilySpecified` does not apply here.
    /// 
    /// &larr; `DirichletFlag`(`int*`): Flag indicating if the dataset contains Dirichlet data.
    /// 
    /// &larr; `NeumannFlag`(`int*`): Flag indicating if the dataset contains Neumann data.
    pub fn cg_bcdataset_read(
        index: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        BCType: *mut BCType_t,
        DirichletFlag: *mut ::std::os::raw::c_int,
        NeumannFlag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Write boundary condition data
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &rarr; `Dset`(`int`): Dataset index number, where 1 &le; `Dset` &le; `ndataset`.
    /// 
    /// &rarr; `BCDataType`(`BCDataType_t`): Type of boundary condition in the dataset. Admissible boundary condition types are `Dirichlet` and `Neumann`.
    pub fn cg_bcdata_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        Dset: ::std::os::raw::c_int,
        BCDataType: BCDataType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `ndiscrete`(`int*`): Number of `DiscreteData_t` data structures under zone `Z`.
    pub fn cg_ndiscrete(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        ndiscrete: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `D`(`int`): Discrete data index number, where 1 &le; `D` &le; `ndiscrete`.
    /// 
    /// &larr; `DiscreteName`(`char*`): Name of `DiscreteData_t` data structure.
    pub fn cg_discrete_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        D: ::std::os::raw::c_int,
        discrete_name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `DiscreteName`(`char*`): Name of `DiscreteData_t` data structure.
    /// 
    /// &larr; `D`(`int*`): Discrete data index number, where 1 &le; `D` &le; `ndiscrete`.
    pub fn cg_discrete_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        discrete_name: *const ::std::os::raw::c_char,
        D: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `D`(`int`): Discrete data index number, where 1 &le; `D` &le; `ndiscrete`.
    /// 
    /// &larr; `data_dim`(`int*`): Number of dimensions defining the discrete data. If a point set has been defined, this will be 1, otherwise this will be the current zone index dimension.</td>
    /// 
    /// &larr; `dim_vals`(`cgsize_t*`): The array of `data_dim` dimensions for the discrete data.</td>
    pub fn cg_discrete_size(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        D: ::std::os::raw::c_int,
        data_dim: *mut ::std::os::raw::c_int,
        dim_vals: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `D`(`int`): Discrete data index number, where 1 &le; `D` &le; `ndiscrete`.
    /// 
    /// &larr; `ptset_type`(`PointSetType_t*`): Type of point set defining the interface for the discrete data; either `PointRange` or `PointList`.
    /// 
    /// &larr; `npnts`(`cgsize_t*`): Number of points defining the interface for the discrete data. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the list.
    pub fn cg_discrete_ptset_info(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        D: ::std::os::raw::c_int,
        ptset_type: *mut PointSetType_t,
        npnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `D`(`int`): Discrete data index number, where 1 &le; `D` &le; `ndiscrete`.
    /// 
    /// &larr; `pnts`(`cgsize_t*`): Array of points defining the interface for the discrete data.
    pub fn cg_discrete_ptset_read(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        D: ::std::os::raw::c_int,
        pnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `char `(`const`): undefined
    /// 
    /// &rarr; `location`(`GridLocation_t`): Grid location where the discrete data is recorded. The current admissible locations are `Vertex`, `CellCenter`, `IFaceCenter`, `JFaceCenter`, and `KFaceCenter`.
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): Type of point set defining the interface for the discrete data; either `PointRange` or `PointList`.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): Number of points defining the interface for the discrete data. For a `ptset_type` of `PointRange`, `npnts` is always two. For a `ptset_type` of `PointList`, `npnts` is the number of points in the list.
    /// 
    /// &rarr; `cgsize_t `(`const`): undefined
    /// 
    /// &larr; `D`(`int*`): Discrete data index number, where 1 &le; `D` &le; `ndiscrete`.
    pub fn cg_discrete_ptset_write(
        fn_: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        discrete_name: *const ::std::os::raw::c_char,
        location: GridLocation_t,
        ptset_type: PointSetType_t,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
        D: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `n_rigid_motions`(`int*`): Number of `RigidGridMotion_t` nodes under zone `Z`.
    pub fn cg_n_rigid_motions(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        n_rigid_motions: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `R`(`int`): Rigid rotation index number, where 1 &le; `R` &le; `n_rigid_motions`.
    /// 
    /// &larr; `RigidGridMotionName`(`char*`): Name of the `RigidGridMotion_t` node.
    /// 
    /// &larr; `RigidGridMotionType`(`RigidGridMotionType_t`): Type of rigid grid motion. The admissible types are `CG_Null`, `CG_UserDefined`, `ConstantRate`, and `VariableRate`.
    pub fn cg_rigid_motion_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        R: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        type_: *mut RigidGridMotionType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `RigidGridMotionName`(`char*`): Name of the `RigidGridMotion_t` node.
    /// 
    /// &rarr; `RigidGridMotionType`(`RigidGridMotionType_t`): Type of rigid grid motion. The admissible types are `CG_Null`, `CG_UserDefined`, `ConstantRate`, and `VariableRate`.
    /// 
    /// &larr; `R`(`int*`): Rigid rotation index number, where 1 &le; `R` &le; `n_rigid_motions`.
    pub fn cg_rigid_motion_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: RigidGridMotionType_t,
        R: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `n_arbitrary_motions`(`int*`): Number of `ArbitraryGridMotion_t` nodes under zone `Z`.
    pub fn cg_n_arbitrary_motions(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        n_arbitrary_motions: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `A`(`int`): Arbitrary grid motion index number, where 1 &le; `A` &le; `n_arbitrary_motions`.
    /// 
    /// &larr; `ArbitraryGridMotionName`(`char*`): Name of the `ArbitraryGridMotion_t` node.
    /// 
    /// &larr; `ArbitraryGridMotionType`(`ArbitraryGridMotionType_t`): Type of arbitrary grid motion. The admissible types are `CG_Null`, `CG_UserDefined`, `NonDeformingGrid`, and `DeformingGrid`.
    pub fn cg_arbitrary_motion_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        A: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        type_: *mut ArbitraryGridMotionType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `ArbitraryGridMotionName`(`char*`): Name of the `ArbitraryGridMotion_t` node.
    /// 
    /// &rarr; `ArbitraryGridMotionType`(`ArbitraryGridMotionType_t`): Type of arbitrary grid motion. The admissible types are `CG_Null`, `CG_UserDefined`, `NonDeformingGrid`, and `DeformingGrid`.
    /// 
    /// &larr; `A`(`int*`): Arbitrary grid motion index number, where 1 &le; `A` &le; `n_arbitrary_motions`.
    pub fn cg_arbitrary_motion_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        amotionname: *const ::std::os::raw::c_char,
        type_: ArbitraryGridMotionType_t,
        A: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read simulation type
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `SimulationType`(`SimulationType_t`): Type of simulation. Valid types are `CG_Null`, `CG_UserDefined`, `TimeAccurate`, and `NonTimeAccurate`.
    pub fn cg_simulation_type_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        type_: *mut SimulationType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `SimulationType`(`SimulationType_t`): Type of simulation. Valid types are `CG_Null`, `CG_UserDefined`, `TimeAccurate`, and `NonTimeAccurate`.
    pub fn cg_simulation_type_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        type_: SimulationType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `BaseIterName`(`char*`): Name of the `BaseIterativeData_t` node.
    /// 
    /// &larr; `Nsteps`(`int*`): Number of time steps or iterations.
    pub fn cg_biter_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        bitername: *mut ::std::os::raw::c_char,
        nsteps: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `BaseIterName`(`char*`): Name of the `BaseIterativeData_t` node.
    /// 
    /// &rarr; `Nsteps`(`int`): Number of time steps or iterations.
    pub fn cg_biter_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        bitername: *const ::std::os::raw::c_char,
        nsteps: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &larr; `ZoneIterName`(`char*`): Name of the `ZoneIterativeData_t` node.
    pub fn cg_ziter_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        zitername: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `ZoneIterName`(`char*`): Name of the `ZoneIterativeData_t` node.
    pub fn cg_ziter_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        zitername: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `GravityVector`(`float*`): Components of the gravity vector. The number of components must equal `PhysicalDimension`. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_gravity_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        gravity_vector: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `GravityVector`(`float*`): Components of the gravity vector. The number of components must equal `PhysicalDimension`. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_gravity_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        gravity_vector: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read axisymmetry data
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &larr; `ReferencePoint`(`float*`): Origin used for defining the axis of rotation. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &larr; `AxisVector`(`float*`): Direction cosines of the axis of rotation, through the reference point. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_axisym_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        ref_point: *mut f32,
        axis: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `ReferencePoint`(`float*`): Origin used for defining the axis of rotation. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &rarr; `AxisVector`(`float*`): Direction cosines of the axis of rotation, through the reference point. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_axisym_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        ref_point: *const f32,
        axis: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read rotating coordinates data
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `RotationRateVector`(`float*`): Components of the angular velocity of the grid about the center of rotation. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &larr; `RotationCenter`(`float*`): Coordinates of the center of rotation. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_rotating_read(rot_rate: *mut f32, rot_center: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `RotationRateVector`(`float*`): Components of the angular velocity of the grid about the center of rotation. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &rarr; `RotationCenter`(`float*`): Coordinates of the center of rotation. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_rotating_write(rot_rate: *const f32, rot_center: *const f32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    pub fn cg_bc_wallfunction_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        WallFunctionType: *mut WallFunctionType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &rarr; `WallFunctionType`(`WallFunctionType_t`): The wall function type. Valid types are `CG_Null`, `CG_UserDefined`, and `Generic`.
    pub fn cg_bc_wallfunction_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        WallFunctionType: WallFunctionType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read area-related data
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &larr; `AreaType`(`AreaType_t*`): The type of area. Valid types are `CG_Null`, `CG_UserDefined`, `BleedArea`, and `CaptureArea`.
    /// 
    /// &larr; `SurfaceArea`(`float*`): The size of the area. (In Fortran, this is a Real*4 value.)
    /// 
    /// &larr; `RegionName`(`char*`): The name of the region, 32 characters max.
    pub fn cg_bc_area_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        AreaType: *mut AreaType_t,
        SurfaceArea: *mut f32,
        RegionName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `BC`(`int`): Boundary condition index number, where 1 &le; `BC` &le; `nbocos`.
    /// 
    /// &rarr; `AreaType`(`AreaType_t`): The type of area. Valid types are `CG_Null`, `CG_UserDefined`, `BleedArea`, and `CaptureArea`.
    /// 
    /// &rarr; `SurfaceArea`(`float`): The size of the area. (In Fortran, this is a Real*4 value.)
    /// 
    /// &rarr; `RegionName`(`char*`): The name of the region, 32 characters max.
    pub fn cg_bc_area_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        BC: ::std::os::raw::c_int,
        AreaType: AreaType_t,
        SurfaceArea: f32,
        RegionName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &larr; `RotationCenter`(`float*`): An array of size `phys_dim` defining the coordinates of the origin for defining the rotation angle between the periodic interfaces. (`phys_dim` is the number of coordinates required to define a vector in the field.) (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &larr; `RotationAngle`(`float*`): An array of size `phys_dim` defining the rotation angle from the current interface to the connecting interface. If rotating about more than one axis, the rotation is performed first about the x-axis, then the y-axis, then the z-axis. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &larr; `Translation`(`float*`): An array of size `phys_dim` defining the translation from the current interface to the connecting interface. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_conn_periodic_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        RotationCenter: *mut f32,
        RotationAngle: *mut f32,
        Translation: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &rarr; `RotationCenter`(`float*`): An array of size `phys_dim` defining the coordinates of the origin for defining the rotation angle between the periodic interfaces. (`phys_dim` is the number of coordinates required to define a vector in the field.) (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &rarr; `RotationAngle`(`float*`): An array of size `phys_dim` defining the rotation angle from the current interface to the connecting interface. If rotating about more than one axis, the rotation is performed first about the x-axis, then the y-axis, then the z-axis. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &rarr; `Translation`(`float*`): An array of size `phys_dim` defining the translation from the current interface to the connecting interface. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_conn_periodic_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        RotationCenter: *const f32,
        RotationAngle: *const f32,
        Translation: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &rarr; `RotationCenter`(`float*`): An array of size `phys_dim` defining the coordinates of the origin for defining the rotation angle between the periodic interfaces. (`phys_dim` is the number of coordinates required to define a vector in the field.) (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &rarr; `RotationAngle`(`float*`): An array of size `phys_dim` defining the rotation angle from the current interface to the connecting interface. If rotating about more than one axis, the rotation is performed first about the x-axis, then the y-axis, then the z-axis. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &rarr; `Translation`(`float*`): An array of size `phys_dim` defining the translation from the current interface to the connecting interface. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_1to1_periodic_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        RotationCenter: *const f32,
        RotationAngle: *const f32,
        Translation: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &larr; `RotationCenter`(`float*`): An array of size `phys_dim` defining the coordinates of the origin for defining the rotation angle between the periodic interfaces. (`phys_dim` is the number of coordinates required to define a vector in the field.) (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &larr; `RotationAngle`(`float*`): An array of size `phys_dim` defining the rotation angle from the current interface to the connecting interface. If rotating about more than one axis, the rotation is performed first about the x-axis, then the y-axis, then the z-axis. (In Fortran, this is an array of Real*4 values.)
    /// 
    /// &larr; `Translation`(`float*`): An array of size `phys_dim` defining the translation from the current interface to the connecting interface. (In Fortran, this is an array of Real*4 values.)
    pub fn cg_1to1_periodic_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        RotationCenter: *mut f32,
        RotationAngle: *mut f32,
        Translation: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read data for averaging interface
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &larr; `AverageInterfaceType`(`AverageInterfaceType_t*`): The type of averaging to be done. Valid types are `CG_Null`, `CG_UserDefined`, `AverageAll`, `AverageCircumferential`, `AverageRadial`, `AverageI`, `AverageJ`, and `AverageK`.
    pub fn cg_conn_average_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        AverageInterfaceType: *mut AverageInterfaceType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &rarr; `AverageInterfaceType`(`AverageInterfaceType_t`): The type of averaging to be done. Valid types are `CG_Null`, `CG_UserDefined`, `AverageAll`, `AverageCircumferential`, `AverageRadial`, `AverageI`, `AverageJ`, and `AverageK`.
    pub fn cg_conn_average_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        AverageInterfaceType: AverageInterfaceType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &rarr; `AverageInterfaceType`(`AverageInterfaceType_t`): The type of averaging to be done. Valid types are `CG_Null`, `CG_UserDefined`, `AverageAll`, `AverageCircumferential`, `AverageRadial`, `AverageI`, `AverageJ`, and `AverageK`.
    pub fn cg_1to1_average_write(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        AverageInterfaceType: AverageInterfaceType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number.
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`.
    /// 
    /// &rarr; `Z`(`int`): Zone index number, where 1 &le; `Z` &le; `nzones`.
    /// 
    /// &rarr; `I`(`int`): Grid connectivity index number, where 1 &le; `I` &le; `nconns` for the "`cg_conn`" functions, and 1 &le; `I` &le; `n1to1` for the "`cg_1to1`" functions.
    /// 
    /// &larr; `AverageInterfaceType`(`AverageInterfaceType_t*`): The type of averaging to be done. Valid types are `CG_Null`, `CG_UserDefined`, `AverageAll`, `AverageCircumferential`, `AverageRadial`, `AverageI`, `AverageJ`, and `AverageK`.
    pub fn cg_1to1_average_read(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        Z: ::std::os::raw::c_int,
        Ii: ::std::os::raw::c_int,
        AverageInterfaceType: *mut AverageInterfaceType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number. <br><br>
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`. <br><br>
    pub fn cg_goto(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_goto_f08(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number. <br><br>
    pub fn cg_gorel(file_number: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_gorel_f08(file_number: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number. <br><br>
    /// 
    /// &rarr; `char `(`const`): undefined
    pub fn cg_gopath(
        file_number: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `fn`(`int`): CGNS file index number. <br><br>
    /// 
    /// &rarr; `B`(`int`): Base index number, where 1 &le; `B` &le; `nbases`. <br><br>
    /// 
    /// &rarr; `depth`(`int`): Depth of the path list. The maximum depth is defined in <i>cgnslib.h</i> by `CG_MAX_GOTO_DEPTH`, and is currently equal to 20. <br><br>
    /// 
    /// &rarr; `label`(`char**`): Array of node labels for the path. This argument may be passed as `NULL` to `cg_where()`, otherwise it must be dimensioned by the calling program. The maximum size required is `label[MAX_GO_TO_DEPTH][33]`. You may call `cg_where()` with both `label` and `index` set to `NULL` in order to get the current depth, then dimension to that value. <br><br>
    /// 
    /// &rarr; `index`(`int*`): Array of node indices for the path. This argument may be passed as `NULL` to `cg_where()`, otherwise it must be dimensioned by the calling program. The maximum size required is `index[MAX_GO_TO_DEPTH]`. You may call `cg_where()` with both `label` and `index` set to `NULL` in order to get the current depth, then dimension to that value. <br><br>
    pub fn cg_golist(
        file_number: ::std::os::raw::c_int,
        B: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        label: *mut *mut ::std::os::raw::c_char,
        num: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get path to current node
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `fn`(`int*`): CGNS file index number. <br><br>
    /// 
    /// &larr; `B`(`int*`): Base index number, where 1 &le; `B` &le; `nbases`. <br><br>
    /// 
    /// &larr; `depth`(`int*`): Depth of the path list. The maximum depth is defined in <i>cgnslib.h</i> by `CG_MAX_GOTO_DEPTH`, and is currently equal to 20. <br><br>
    /// 
    /// &larr; `label`(`char**`): Array of node labels for the path. This argument may be passed as `NULL` to `cg_where()`, otherwise it must be dimensioned by the calling program. The maximum size required is `label[MAX_GO_TO_DEPTH][33]`. You may call `cg_where()` with both `label` and `index` set to `NULL` in order to get the current depth, then dimension to that value. <br><br>
    /// 
    /// &larr; `index`(`int*`): Array of node indices for the path. This argument may be passed as `NULL` to `cg_where()`, otherwise it must be dimensioned by the calling program. The maximum size required is `index[MAX_GO_TO_DEPTH]`. You may call `cg_where()` with both `label` and `index` set to `NULL` in order to get the current depth, then dimension to that value. <br><br>
    pub fn cg_where(
        file_number: *mut ::std::os::raw::c_int,
        B: *mut ::std::os::raw::c_int,
        depth: *mut ::std::os::raw::c_int,
        label: *mut *mut ::std::os::raw::c_char,
        num: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `niterations`(`int*`): Number of iterations for which convergence information is recorded.
    /// 
    /// &larr; `NormDefinitions`(`char**`): Description of the convergence information recorded in the data arrays.
    pub fn cg_convergence_read(
        iterations: *mut ::std::os::raw::c_int,
        NormDefinitions: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `niterations`(`int`): Number of iterations for which convergence information is recorded.
    /// 
    /// &rarr; `NormDefinitions`(`char*`): Description of the convergence information recorded in the data arrays.
    pub fn cg_convergence_write(
        iterations: ::std::os::raw::c_int,
        NormDefinitions: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read text description of reference state.
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `StateDescription`(`char**`): Text description of reference state.
    pub fn cg_state_read(
        StateDescription: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `StateDescription`(`char*`): Text description of reference state.
    pub fn cg_state_write(StateDescription: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `EquationDimension`(`int*`): Dimensionality of the governing equations; it is the number of spatial variables describing the flow.
    /// 
    /// &larr; `GoverningEquationsFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of the governing equations; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `GasModelFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a gas model; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `ViscosityModelFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a viscosity model; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `ThermalConductModelFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a thermal conductivity model; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `TurbulenceClosureFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of the turbulence closure; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `TurbulenceModelFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a turbulence model; 0 if it doesn't, 1 if it does.
    pub fn cg_equationset_read(
        EquationDimension: *mut ::std::os::raw::c_int,
        GoverningEquationsFlag: *mut ::std::os::raw::c_int,
        GasModelFlag: *mut ::std::os::raw::c_int,
        ViscosityModelFlag: *mut ::std::os::raw::c_int,
        ThermalConductivityModelFlag: *mut ::std::os::raw::c_int,
        TurbulenceClosureFlag: *mut ::std::os::raw::c_int,
        TurbulenceModelFlag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `ThermalRelaxationFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a thermal relaxation model; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `ChemicalKineticsFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a chemical kinetics model; 0 if it doesn't, 1 if it does.
    pub fn cg_equationset_chemistry_read(
        ThermalRelaxationFlag: *mut ::std::os::raw::c_int,
        ChemicalKineticsFlag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read electromagnetic equation set info
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `ElecFldModelFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of an electric field model for electromagnetic flows;; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `MagnFldModelFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a magnetic field model for electromagnetic flows;; 0 if it doesn't, 1 if it does.
    /// 
    /// &larr; `ConductivityModelFlag`(`int*`): Flag indicating whether or not this `FlowEquationSet_t` node includes the definition of a conductivity model for electromagnetic flows; 0 if it doesn't, 1 if it does.
    pub fn cg_equationset_elecmagn_read(
        ElecFldModelFlag: *mut ::std::os::raw::c_int,
        MagnFldModelFlag: *mut ::std::os::raw::c_int,
        ConductivityModelFlag: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `EquationDimension`(`int`): Dimensionality of the governing equations; it is the number of spatial variables describing the flow.
    pub fn cg_equationset_write(EquationDimension: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `EquationsType`(`GoverningEquationsType_t*`): Type of governing equations. The admissible types are `CG_Null`, `CG_UserDefined`, `FullPotential`, `Euler`, `NSLaminar`, `NSTurbulent`, `NSLaminarIncompressible`, and `NSTurbulentIncompressible`.
    pub fn cg_governing_read(EquationsType: *mut GoverningEquationsType_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `Equationstype`(`GoverningEquationsType_t`): undefined
    pub fn cg_governing_write(Equationstype: GoverningEquationsType_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read flags for diffusion terms
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `diffusion_model`(`int*`): Flags defining which diffusion terms are included in the governing equations. This is only applicable to the Navier-Stokes equations with structured grids. See the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/floweqn.html#DiffusionModel>discussion in the SIDS manual</a> for details.
    pub fn cg_diffusion_read(diffusion_model: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `diffusion_model`(`int*`): Flags defining which diffusion terms are included in the governing equations. This is only applicable to the Navier-Stokes equations with structured grids. See the <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/floweqn.html#DiffusionModel>discussion in the SIDS manual</a> for details.
    pub fn cg_diffusion_write(
        diffusion_model: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read auxiliary model types
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `ModelLabel`(`char*`): The CGNS label for the model being defined. The models supported by CGNS are: <ul> <li>`GasModel_t` <li>`ViscosityModel_t` <li>`ThermalConductivityModel_t` <li>`TurbulenceClosure_t` <li>`TurbulenceModel_t` <li>`ThermalRelaxationModel_t` <li>`ChemicalKineticsModel_t` <li>`EMElectricFieldModel_t` <li>`EMMagneticFieldModel_t` <li>`EMConductivityModel_t` </ul>
    /// 
    /// &larr; `ModelType`(`ModelType_t*`): One of the model types (listed below) allowed for the `ModelLabel` selected.
    pub fn cg_model_read(
        ModelLabel: *const ::std::os::raw::c_char,
        ModelType: *mut ModelType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `ModelLabel`(`char*`): The CGNS label for the model being defined. The models supported by CGNS are: <ul> <li>`GasModel_t` <li>`ViscosityModel_t` <li>`ThermalConductivityModel_t` <li>`TurbulenceClosure_t` <li>`TurbulenceModel_t` <li>`ThermalRelaxationModel_t` <li>`ChemicalKineticsModel_t` <li>`EMElectricFieldModel_t` <li>`EMMagneticFieldModel_t` <li>`EMConductivityModel_t` </ul>
    /// 
    /// &rarr; `ModelType`(`ModelType_t`): One of the model types (listed below) allowed for the `ModelLabel` selected.
    pub fn cg_model_write(
        ModelLabel: *const ::std::os::raw::c_char,
        ModelType: ModelType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `narrays`(`int*`): Number of `DataArray_t` nodes under the current node.
    pub fn cg_narrays(narrays: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `A`(`int`): Data array index, where 1 &le; `A` &le; `narrays`.
    /// 
    /// &larr; `arrayname`(`char*`): Name of the `DataArray_t` node.
    /// 
    /// &larr; `datatype`(`DataType_t*`): Type of data held in the `DataArray_t` node. The admissible types are `Integer`, `LongInteger`, `RealSingle`, `RealDouble`, and `Character`.
    /// 
    /// &larr; `rank`(`int*`): Number of dimensions of array in file (max 12). See <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../cgio/node.html>Node Management Routines</a> in CGIO User's Guide.
    /// 
    /// &larr; `dimensions`(`cgsize_t*`): Dimensions of array in file.
    pub fn cg_array_info(
        A: ::std::os::raw::c_int,
        ArrayName: *mut ::std::os::raw::c_char,
        DataType: *mut DataType_t,
        DataDimension: *mut ::std::os::raw::c_int,
        DimensionVector: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `A`(`int`): Data array index, where 1 &le; `A` &le; `narrays`.
    /// 
    /// &larr; `data`(`void*`): The data array in memory.
    pub fn cg_array_read(
        A: ::std::os::raw::c_int,
        Data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `A`(`int`): Data array index, where 1 &le; `A` &le; `narrays`.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Type of data held in the `DataArray_t` node. The admissible types are `Integer`, `LongInteger`, `RealSingle`, `RealDouble`, and `Character`.
    /// 
    /// &larr; `data`(`void*`): The data array in memory.
    pub fn cg_array_read_as(
        A: ::std::os::raw::c_int,
        type_: DataType_t,
        Data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read subset of data array to a shaped array
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `A`(`int`): Data array index, where 1 &le; `A` &le; `narrays`.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): The type of data held in memory. The admissible types are `Integer`, `LongInteger`, `RealSingle`, `RealDouble`, and `Character`.
    /// 
    /// &rarr; `mem_rank`(`int`): Number of dimensions of array in memory (max 12).
    /// 
    /// &rarr; `mem_dimensions`(`cgsize_t*`): Dimensions of array in memory.
    /// 
    /// &rarr; `mem_range_min`(`cgsize_t*`): Lower range index in memory (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `mem_range_max`(`cgsize_t*`): Upper range index in memory (eg., `imax, jmax, kmax`).
    /// 
    /// &larr; `data`(`void*`): The data array in memory.
    pub fn cg_array_general_read(
        A: ::std::os::raw::c_int,
        s_rmin: *const ::std::os::raw::c_int,
        s_rmax: *const ::std::os::raw::c_int,
        m_type: DataType_t,
        m_numdim: ::std::os::raw::c_int,
        m_dimvals: *const ::std::os::raw::c_int,
        m_rmin: *const ::std::os::raw::c_int,
        m_rmax: *const ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `arrayname`(`char*`): Name of the `DataArray_t` node.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Type of data held in the `DataArray_t` node. The admissible types are `Integer`, `LongInteger`, `RealSingle`, `RealDouble`, and `Character`.
    /// 
    /// &rarr; `rank`(`int`): Number of dimensions of array in file (max 12). See <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../cgio/node.html>Node Management Routines</a> in CGIO User's Guide.
    /// 
    /// &rarr; `dimensions`(`cgsize_t*`): Dimensions of array in file.
    /// 
    /// &rarr; `data`(`void*`): The data array in memory.
    pub fn cg_array_write(
        ArrayName: *const ::std::os::raw::c_char,
        DataType: DataType_t,
        DataDimension: ::std::os::raw::c_int,
        DimensionVector: *const ::std::os::raw::c_int,
        Data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `arrayname`(`char*`): Name of the `DataArray_t` node.
    /// 
    /// &rarr; `datatype`(`DataType_t`): Type of data held in the `DataArray_t` node. The admissible types are `Integer`, `LongInteger`, `RealSingle`, `RealDouble`, and `Character`.
    /// 
    /// &rarr; `rank`(`int`): Number of dimensions of array in file (max 12). See <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../cgio/node.html>Node Management Routines</a> in CGIO User's Guide.
    /// 
    /// &rarr; `dimensions`(`cgsize_t*`): Dimensions of array in file.
    /// 
    /// &rarr; `range_min`(`cgsize_t*`): Lower range index in file (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `range_max`(`cgsize_t*`): Upper range index in file (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `mem_datatype`(`DataType_t`): The type of data held in memory. The admissible types are `Integer`, `LongInteger`, `RealSingle`, `RealDouble`, and `Character`.
    /// 
    /// &rarr; `mem_rank`(`int`): Number of dimensions of array in memory (max 12).
    /// 
    /// &rarr; `mem_dimensions`(`cgsize_t*`): Dimensions of array in memory.
    /// 
    /// &rarr; `mem_range_min`(`cgsize_t*`): Lower range index in memory (eg., `imin, jmin, kmin`).
    /// 
    /// &rarr; `mem_range_max`(`cgsize_t*`): Upper range index in memory (eg., `imax, jmax, kmax`).
    /// 
    /// &rarr; `data`(`void*`): The data array in memory.
    pub fn cg_array_general_write(
        arrayname: *const ::std::os::raw::c_char,
        s_type: DataType_t,
        s_numdim: ::std::os::raw::c_int,
        s_dimvals: *const ::std::os::raw::c_int,
        s_rmin: *const ::std::os::raw::c_int,
        s_rmax: *const ::std::os::raw::c_int,
        m_type: DataType_t,
        m_numdim: ::std::os::raw::c_int,
        m_dimvals: *const ::std::os::raw::c_int,
        m_rmin: *const ::std::os::raw::c_int,
        m_rmax: *const ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `nuserdata`(`int*`): Number of `UserDefinedData_t` nodes under current node.
    pub fn cg_nuser_data(nuser_data: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `Index`(`int`): User-defined data index number, where 1 &le; `Index` &le; `nuserdata`.
    /// 
    /// &larr; `Name`(`char*`): Name of the `UserDefinedData_t` node.
    pub fn cg_user_data_read(
        Index: ::std::os::raw::c_int,
        user_data_name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `Name`(`char*`): Name of the `UserDefinedData_t` node.
    pub fn cg_user_data_write(
        user_data_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `nintegrals`(`int*`): Number of `IntegralData_t` nodes under current node.
    pub fn cg_nintegrals(nintegrals: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `Index`(`int`): Integral data index number, where 1 &le; `Index` &le; `nintegrals`.
    /// 
    /// &larr; `Name`(`char*`): Name of the `IntegralData_t` data structure.
    pub fn cg_integral_read(
        IntegralDataIndex: ::std::os::raw::c_int,
        IntegralDataName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `Name`(`char*`): Name of the `IntegralData_t` data structure.
    pub fn cg_integral_write(
        IntegralDataName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read number of rind layers
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `RindData`(`int*`): Number of rind layers for each computational direction (structured grid) or number of rind points or elements (unstructured grid).  For structured grids, the low/high sides have unit stride in the array (e.g., `[NRindLowI, NRindHighI, NRindLowJ, NRindHighJ, NRindLowK, NRindHighK]`).
    pub fn cg_rind_read(RindData: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `RindData`(`int*`): Number of rind layers for each computational direction (structured grid) or number of rind points or elements (unstructured grid).  For structured grids, the low/high sides have unit stride in the array (e.g., `[NRindLowI, NRindHighI, NRindLowJ, NRindHighJ, NRindLowK, NRindHighK]`).
    pub fn cg_rind_write(RindData: *const ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `ndescriptors`(`int*`): Number of `Descriptor_t` nodes under the current node.
    pub fn cg_ndescriptors(ndescriptors: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read descriptive text
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `D`(`int`): Descriptor index number, where 1 &le; `D` &le; `ndescriptors`.
    /// 
    /// &larr; `name`(`char*`): Name of the `Descriptor_t` node.
    /// 
    /// &larr; `text`(`char**`): Description held in the `Descriptor_t` node.
    pub fn cg_descriptor_read(
        descr_no: ::std::os::raw::c_int,
        descr_name: *mut ::std::os::raw::c_char,
        descr_text: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `name`(`char*`): Name of the `Descriptor_t` node.
    /// 
    /// &rarr; `text`(`char*`): Description held in the `Descriptor_t` node.
    pub fn cg_descriptor_write(
        descr_name: *const ::std::os::raw::c_char,
        descr_text: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `nunits`(`int*`): Number of units used in the file (i.e., either 5 or 8).
    pub fn cg_nunits(nunits: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `mass`(`MassUnits_t*`): Mass units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kilogram`, `Gram`, `Slug`, and `PoundMass`.
    /// 
    /// &larr; `length`(`LengthUnits_t*`): Length units. Admissible values are `CG_Null`, `CG_UserDefined`, `Meter`, `Centimeter`, `Millimeter`, `Foot`, and `Inch`.
    /// 
    /// &larr; `time`(`TimeUnits_t*`): Time units. Admissible values are `CG_Null`, `CG_UserDefined`, and `Second`.
    /// 
    /// &larr; `temperature`(`TemperatureUnits_t*`): Temperature units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kelvin`, `Celsius`, `Rankine`, and `Fahrenheit`.
    /// 
    /// &larr; `angle`(`AngleUnits_t*`): Angle units. Admissible values are `CG_Null`, `CG_UserDefined`, `Degree`, and `Radian`.
    pub fn cg_units_read(
        mass: *mut MassUnits_t,
        length: *mut LengthUnits_t,
        time: *mut TimeUnits_t,
        temperature: *mut TemperatureUnits_t,
        angle: *mut AngleUnits_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `mass`(`MassUnits_t`): Mass units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kilogram`, `Gram`, `Slug`, and `PoundMass`.
    /// 
    /// &rarr; `length`(`LengthUnits_t`): Length units. Admissible values are `CG_Null`, `CG_UserDefined`, `Meter`, `Centimeter`, `Millimeter`, `Foot`, and `Inch`.
    /// 
    /// &rarr; `time`(`TimeUnits_t`): Time units. Admissible values are `CG_Null`, `CG_UserDefined`, and `Second`.
    /// 
    /// &rarr; `temperature`(`TemperatureUnits_t`): Temperature units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kelvin`, `Celsius`, `Rankine`, and `Fahrenheit`.
    /// 
    /// &rarr; `angle`(`AngleUnits_t`): Angle units. Admissible values are `CG_Null`, `CG_UserDefined`, `Degree`, and `Radian`.
    pub fn cg_units_write(
        mass: MassUnits_t,
        length: LengthUnits_t,
        time: TimeUnits_t,
        temperature: TemperatureUnits_t,
        angle: AngleUnits_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read all eight dimensional units
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `mass`(`MassUnits_t*`): Mass units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kilogram`, `Gram`, `Slug`, and `PoundMass`.
    /// 
    /// &larr; `length`(`LengthUnits_t*`): Length units. Admissible values are `CG_Null`, `CG_UserDefined`, `Meter`, `Centimeter`, `Millimeter`, `Foot`, and `Inch`.
    /// 
    /// &larr; `time`(`TimeUnits_t*`): Time units. Admissible values are `CG_Null`, `CG_UserDefined`, and `Second`.
    /// 
    /// &larr; `temperature`(`TemperatureUnits_t*`): Temperature units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kelvin`, `Celsius`, `Rankine`, and `Fahrenheit`.
    /// 
    /// &larr; `angle`(`AngleUnits_t*`): Angle units. Admissible values are `CG_Null`, `CG_UserDefined`, `Degree`, and `Radian`.
    /// 
    /// &larr; `current`(`ElectricCurrentUnits_t*`): Electric current units. Admissible values are `CG_Null`, `CG_UserDefined`, `Ampere`, `Abampere`, `Statampere`, `Edison`, and `auCurrent`.
    /// 
    /// &larr; `amount`(`SubstanceAmountUnits_t*`): Substance amount units. Admissible values are `CG_Null`, `CG_UserDefined`, `Mole`, `Entities`, `StandardCubicFoot`, and `StandardCubicMeter`.
    /// 
    /// &larr; `intensity`(`LuminousIntensityUnits_t*`): Luminous intensity units. Admissible values are `CG_Null`, `CG_UserDefined`, `Candela`, `Candle`, `Carcel`, `Hefner`, and `Violle`.
    pub fn cg_unitsfull_read(
        mass: *mut MassUnits_t,
        length: *mut LengthUnits_t,
        time: *mut TimeUnits_t,
        temperature: *mut TemperatureUnits_t,
        angle: *mut AngleUnits_t,
        current: *mut ElectricCurrentUnits_t,
        amount: *mut SubstanceAmountUnits_t,
        intensity: *mut LuminousIntensityUnits_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `mass`(`MassUnits_t`): Mass units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kilogram`, `Gram`, `Slug`, and `PoundMass`.
    /// 
    /// &rarr; `length`(`LengthUnits_t`): Length units. Admissible values are `CG_Null`, `CG_UserDefined`, `Meter`, `Centimeter`, `Millimeter`, `Foot`, and `Inch`.
    /// 
    /// &rarr; `time`(`TimeUnits_t`): Time units. Admissible values are `CG_Null`, `CG_UserDefined`, and `Second`.
    /// 
    /// &rarr; `temperature`(`TemperatureUnits_t`): Temperature units. Admissible values are `CG_Null`, `CG_UserDefined`, `Kelvin`, `Celsius`, `Rankine`, and `Fahrenheit`.
    /// 
    /// &rarr; `angle`(`AngleUnits_t`): Angle units. Admissible values are `CG_Null`, `CG_UserDefined`, `Degree`, and `Radian`.
    /// 
    /// &rarr; `current`(`ElectricCurrentUnits_t`): Electric current units. Admissible values are `CG_Null`, `CG_UserDefined`, `Ampere`, `Abampere`, `Statampere`, `Edison`, and `auCurrent`.
    /// 
    /// &rarr; `amount`(`SubstanceAmountUnits_t`): Substance amount units. Admissible values are `CG_Null`, `CG_UserDefined`, `Mole`, `Entities`, `StandardCubicFoot`, and `StandardCubicMeter`.
    /// 
    /// &rarr; `intensity`(`LuminousIntensityUnits_t`): Luminous intensity units. Admissible values are `CG_Null`, `CG_UserDefined`, `Candela`, `Candle`, `Carcel`, `Hefner`, and `Violle`.
    pub fn cg_unitsfull_write(
        mass: MassUnits_t,
        length: LengthUnits_t,
        time: TimeUnits_t,
        temperature: TemperatureUnits_t,
        angle: AngleUnits_t,
        current: ElectricCurrentUnits_t,
        amount: SubstanceAmountUnits_t,
        intensity: LuminousIntensityUnits_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `DataType`(`DataType_t*`): Data type in which the exponents are recorded. Admissible data types for the exponents are `RealSingle` and `RealDouble`.
    pub fn cg_exponents_info(DataType: *mut DataType_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `nexponents`(`int*`): Number of exponents used in the file (i.e., either 5 or 8).
    pub fn cg_nexponents(numexp: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `exponents`(`void*`): Exponents for the dimensional units for mass, length, time, temperature, angle, electric current, substance amount, and luminous intensity, in that order.
    pub fn cg_exponents_read(exponents: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `DataType`(`DataType_t`): Data type in which the exponents are recorded. Admissible data types for the exponents are `RealSingle` and `RealDouble`.
    /// 
    /// &rarr; `exponents`(`void*`): Exponents for the dimensional units for mass, length, time, temperature, angle, electric current, substance amount, and luminous intensity, in that order.
    pub fn cg_exponents_write(
        DataType: DataType_t,
        exponents: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read all eight dimensional exponents
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `exponents`(`void*`): Exponents for the dimensional units for mass, length, time, temperature, angle, electric current, substance amount, and luminous intensity, in that order.
    pub fn cg_expfull_read(exponents: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `DataType`(`DataType_t`): Data type in which the exponents are recorded. Admissible data types for the exponents are `RealSingle` and `RealDouble`.
    /// 
    /// &rarr; `exponents`(`void*`): Exponents for the dimensional units for mass, length, time, temperature, angle, electric current, substance amount, and luminous intensity, in that order.
    pub fn cg_expfull_write(
        DataType: DataType_t,
        exponents: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `DataType`(`DataType_t*`): Data type in which the conversion factors are recorded. Admissible data types for conversion factors are `RealSingle` and `RealDouble`.
    pub fn cg_conversion_info(DataType: *mut DataType_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read conversion factors
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `ConversionFactors`(`void*`): Two-element array containing the scaling and offset factors.
    pub fn cg_conversion_read(
        ConversionFactors: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `DataType`(`DataType_t`): Data type in which the conversion factors are recorded. Admissible data types for conversion factors are `RealSingle` and `RealDouble`.
    /// 
    /// &rarr; `ConversionFactors`(`void*`): Two-element array containing the scaling and offset factors.
    pub fn cg_conversion_write(
        DataType: DataType_t,
        ConversionFactors: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read data class
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `dataclass`(`DataClass_t*`): Data class for the nodes at this level. See below for the data classes currently supported in CGNS.
    pub fn cg_dataclass_read(dataclass: *mut DataClass_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `dataclass`(`DataClass_t`): Data class for the nodes at this level. See below for the data classes currently supported in CGNS.
    pub fn cg_dataclass_write(dataclass: DataClass_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read grid location
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `GridLocation`(`GridLocation_t*`): Location in the grid. The admissible locations are `CG_Null`, `CG_UserDefined`, `Vertex`, `CellCenter`, `FaceCenter`, `IFaceCenter`, `JFaceCenter`, `KFaceCenter`, and `EdgeCenter`.
    pub fn cg_gridlocation_read(GridLocation: *mut GridLocation_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `GridLocation`(`GridLocation_t`): Location in the grid. The admissible locations are `CG_Null`, `CG_UserDefined`, `Vertex`, `CellCenter`, `FaceCenter`, `IFaceCenter`, `JFaceCenter`, `KFaceCenter`, and `EdgeCenter`.
    pub fn cg_gridlocation_write(GridLocation: GridLocation_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read ordinal value
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `Ordinal`(`int*`): Any integer value.
    pub fn cg_ordinal_read(Ordinal: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `Ordinal`(`int`): Any integer value.
    pub fn cg_ordinal_write(Ordinal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `ptset_type`(`PointSetType_t*`): The point set type; either `PointRange` for a range of points or cells, or `PointList` for a list of discrete points or cells.
    /// 
    /// &larr; `npnts`(`cgsize_t*`): The number of points or cells in the point set. For a point set type of `PointRange`, `npnts` is always two. For a point set type of `PointList`, `npnts` is the number of points or cells in the list.
    pub fn cg_ptset_info(
        ptset_type: *mut PointSetType_t,
        npnts: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `ptset_type`(`PointSetType_t`): The point set type; either `PointRange` for a range of points or cells, or `PointList` for a list of discrete points or cells.
    /// 
    /// &rarr; `npnts`(`cgsize_t`): The number of points or cells in the point set. For a point set type of `PointRange`, `npnts` is always two. For a point set type of `PointList`, `npnts` is the number of points or cells in the list.
    /// 
    /// &rarr; `pnts`(`cgsize_t*`): The array of point or cell indices defining the point set. There should be `npnts` values, each of dimension <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/cgnsbase.html#IndexDimension>`IndexDimension`</a> (i.e., 1 for unstructured grids, and 2 or 3 for structured grids with 2-D or 3-D elements, respectively).
    pub fn cg_ptset_write(
        ptset_type: PointSetType_t,
        npnts: ::std::os::raw::c_int,
        pnts: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read point set data
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `pnts`(`cgsize_t*`): The array of point or cell indices defining the point set. There should be `npnts` values, each of dimension <a href=https://cgns.github.io/CGNS_docs_current/midlevel/../sids/cgnsbase.html#IndexDimension>`IndexDimension`</a> (i.e., 1 for unstructured grids, and 2 or 3 for structured grids with 2-D or 3-D elements, respectively).
    pub fn cg_ptset_read(pnts: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `path_length`(`int*`): Length of the path name of the linked node. The value 0 is returned if the node is not a link.
    pub fn cg_is_link(path_length: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get path information for a link at the current location
    /// 
    /// # Modes
    /// 
    /// [ r - m ]
    /// 
    /// # Arguments
    /// 
    /// &larr; `filename`(`char**`): Name of the linked file, or empty string if the link is within the same file.
    /// 
    /// &larr; `link_path`(`char**`): Path name of the node which the link points to.
    pub fn cg_link_read(
        filename: *mut *mut ::std::os::raw::c_char,
        link_path: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// missing summary
    /// 
    /// # Modes
    /// 
    /// [ - w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `nodename`(`char*`): Name of the link node to create, e.g., `GridCoordinates`.
    /// 
    /// &rarr; `filename`(`char*`): Name of the linked file, or empty string if the link is within the same file.
    /// 
    /// &rarr; `name_in_file`(`char*`): Path name of the node which the link points to. This can be a simple or a compound name, e.g., `Base/Zone 1/GridCoordinates`.
    pub fn cg_link_write(
        nodename: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        name_in_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete a node
    /// 
    /// # Modes
    /// 
    /// [ - - m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `NodeName`(`char*`): Name of the child to be deleted.
    pub fn cg_delete_node(node_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Release library-allocated memory
    /// 
    /// # Modes
    /// 
    /// [ r w m ]
    /// 
    /// # Arguments
    /// 
    /// &rarr; `data`(`void*`): Data allocated by the Mid-Level Library.
    pub fn cg_free(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cg_get_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cg_error_exit();
}
extern "C" {
    pub fn cg_error_print();
}
